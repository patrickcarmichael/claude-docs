# Dashboard

**Navigation:** [← Previous](./22-tab.md) | [Index](./index.md) | [Next →](./24-shell-모드.md)

---

# Dashboard
Source: https://docs.cursor.com/ko/account/teams/dashboard

대시보드에서 결제, 사용량, 팀 설정을 관리해

대시보드에서 결제 관리, 사용량 기반 과금 설정, 팀 관리를 한곳에서 할 수 있어.

<div id="overview">
  ## 개요
</div>

팀 활동, 사용 통계, 최신 변경 사항을 한눈에 빠르게 확인해. 개요 페이지에서 워크스페이스 인사이트를 즉시 파악할 수 있어.

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/dashboard.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=48ee98a4d9b168b93c26a03c1af74ddd" data-og-width="3456" width="3456" data-og-height="1944" height="1944" data-path="images/account/team/dashboard.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/dashboard.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=2ac6f157659354866eaa03b38cd1eb90 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/dashboard.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=8e9e84e894a3faf2846e3aae5deb9a2b 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/dashboard.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e1034c739d961ccc69c17ba947edda90 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/dashboard.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=dbeed5506f7ae3fc4fabc7d248d69e64 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/dashboard.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=afac07ce763fccf7eded7248fb990745 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/dashboard.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=c4ed8c8161c3f2a964371a237134b1ae 2500w" />
</Frame>

<div id="settings">
  ## 설정
</div>

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/settings.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=5edb18df1ddc2d20e69abdd83140a509" data-og-width="1390" width="1390" data-og-height="913" height="913" data-path="images/account/team/settings.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/settings.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=4d4c8f244231868bf4111f05b1f46c93 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/settings.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=582ddf5415a973010e3bcbeeb13d4f64 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/settings.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=74a5d5f4644b701adc25b6d847f5752e 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/settings.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=9250830c64e8c3490c3ca6f7b6f65eec 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/settings.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=7ce96a620ac6d447e79abd901b5c6cdc 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/settings.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=6d24738577e0ffd837d87f8926339215 2500w" />
</Frame>

팀 전체 기본 설정과 보안 설정을 관리해. 설정 페이지에는 다음이 들어 있어:

## 팀 & 엔터프라이즈 설정

<AccordionGroup>
  <Accordion title="Privacy Settings">
    팀의 데이터 공유 설정을 제어해. AI 제공자(OpenAI, Anthropic, Google Vertex AI, xAi Grok)에 대해 데이터 미보관(zero data retention) 정책을 구성하고, 팀 전체 프라이버시 정책 적용을 관리해.
  </Accordion>

  {" "}

  <Accordion title="Usage-Based Pricing Settings">
    사용량 기반 과금을 활성화하고 지출 한도를 설정해. 팀 월별 지출 한도와 선택적인 사용자별 한도를 구성해. 이 설정을 관리자만 수정할 수 있게 할지 제어해.
  </Accordion>

  {" "}

  <Accordion title="Bedrock IAM Role">
    안전한 클라우드 연동을 위해 AWS Bedrock IAM 역할을 구성해.
  </Accordion>

  {" "}

  <Accordion title="Single Sign-On (SSO)">
    엔터프라이즈 팀을 위해 SSO 인증을 설정해 사용자 접근을 간소화하고
    보안을 강화해.
  </Accordion>

  {" "}

  <Accordion title="Cursor Admin API Keys">
    Cursor의 관리자 기능에 프로그래매틱하게 접근하기 위한 API 키를 생성하고 관리해.
  </Accordion>

  {" "}

  <Accordion title="Active Sessions">
    팀 전체의 활성 사용자 세션을 모니터링하고 관리해.
  </Accordion>

  <Accordion title="Invite Code Management">
    새 팀원을 추가할 초대 코드를 생성하고 관리해.
  </Accordion>

  <Accordion title="API Endpoints">
    Cursor의 REST API 엔드포인트에 접근해 프로그래매틱 통합을 수행해. 모든 API 엔드포인트는 Team과 Enterprise 플랜에서 사용 가능하지만, [AI Code Tracking API](/ko/docs/account/teams/ai-code-tracking-api)는 Enterprise 멤버십이 필요해.
  </Accordion>
</AccordionGroup>

<div id="enterprise-only-settings">
  ## 엔터프라이즈 전용 설정
</div>

<AccordionGroup>
  {" "}

  <Accordion title="Model Access Control">
    팀 구성원이 사용할 수 있는 AI 모델을 제어해. 특정 모델이나 모델 티어에 제한을 걸어 비용을 관리하고, 조직 전반의 적절한 사용을 보장해.
  </Accordion>

  {" "}

  <Accordion title="Auto Run Configuration (0.49+)">
    Cursor 0.49 이상에서 자동 명령 실행 설정을 구성해. 어떤 명령을 자동으로 실행할지 제어하고, 코드 실행 보안 정책을 설정해.
  </Accordion>

  <Accordion title="Repository Blocklist">
    보안 또는 규정 준수를 위해 특정 리포지토리에 대한 접근을 차단해.
  </Accordion>

  {" "}

  <Accordion title="MCP Configuration (0.51+)">
    Cursor 0.51 이상에서 Model Context Protocol 설정을 구성해. 개발 환경의 컨텍스트에 모델이 접근하고 처리하는 방식을 관리해.
  </Accordion>

  {" "}

  <Accordion title="Cursor Ignore Configuration (0.50+)">
    Cursor 0.50 이상에서 파일과 디렉터리에 대한 ignore 패턴을 설정해. AI 분석과 제안에서 제외할 파일과 디렉터리를 제어해.
  </Accordion>

  <Accordion title=".cursor Directory Protection (0.51+)">
    0.51 이상에서 .cursor 디렉터리를 무단 접근으로부터 보호해. 민감한 설정 및 캐시 파일이 안전하게 유지되도록 해.
  </Accordion>

  <Accordion title="AI Code Tracking API">
    팀 리포지토리에 대한 상세한 AI 생성 코드 분석에 접근해. 커밋 단위 AI 사용 지표와 세분화된 승인된 AI 변경 사항을 REST API 엔드포인트로 가져와. 엔터프라이즈 플랜이 필요해. 자세한 정보는 [여기](/ko/account/teams/ai-code-tracking-api)에서 확인해.
  </Accordion>
</AccordionGroup>

<Note>
  **SCIM**(System for Cross-domain Identity Management) 프로비저닝도 엔터프라이즈 플랜에서 제공돼. 설정 방법은 [SCIM 문서](/ko/account/teams/scim)를 확인해.
</Note>

<div id="members">
  ## Members
</div>

팀 멤버를 관리하고 새 사용자 초대, 접근 권한 제어를 할 수 있어. 역할 기반 권한을 설정하고 멤버 활동을 모니터링해.

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/members.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=4ac43692626733caf2da4b53e4cd9055" data-og-width="1390" width="1390" data-og-height="591" height="591" data-path="images/account/team/members.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/members.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=a2a24d3282df1e875d73fd2bf29b9c04 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/members.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1abe9715816149f577a5d9c9e2f3545d 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/members.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=ccc84260c5139119e5b16ad6c214af72 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/members.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=5fe34e422fa9540004c25a61570029c3 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/members.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=dee7c3ade8ef46b5ead5dbe2bfd2a6be 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/members.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=9a42bce921a799886b8e3e0a389b8589 2500w" />
</Frame>

<div id="integrations">
  ## 통합
</div>

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=187b9e77d6b99c77caec81e1b3063417" data-og-width="1390" width="1390" data-og-height="592" height="592" data-path="images/account/team/integrations.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=470d5697ff2bfb9db2ae745b2c33cce6 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e1e7d589f1f208ecdba9840629897968 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=2285e05c99c3a6ace609b51770475a3e 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=7c44649c5e8cd0f2a3791a3085252eca 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=0cf7111171c8019f7a59adc79cb9639d 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=8423a209b4e1c753045dca1514cbfbad 2500w" />
</Frame>

{" "}

Cursor를 네가 쓰는 즐겨 찾는 도구와 서비스에 연결해봐. 버전 관리 시스템, 프로젝트 관리 도구, 그리고 기타 개발자 서비스와의 통합을 구성할 수 있어.

<div id="background-agents">
  ## 백그라운드 에이전트
</div>

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=187b9e77d6b99c77caec81e1b3063417" data-og-width="1390" width="1390" data-og-height="592" height="592" data-path="images/account/team/integrations.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=470d5697ff2bfb9db2ae745b2c33cce6 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e1e7d589f1f208ecdba9840629897968 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=2285e05c99c3a6ace609b51770475a3e 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=7c44649c5e8cd0f2a3791a3085252eca 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=0cf7111171c8019f7a59adc79cb9639d 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/integrations.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=8423a209b4e1c753045dca1514cbfbad 2500w" />
</Frame>

{" "}

워크스페이스에서 실행 중인 백그라운드 에이전트를 모니터링하고 관리해. 에이전트 상태, 로그, 리소스 사용량을 확인해.

<div id="bugbot">
  ## Bugbot
</div>

자동 버그 탐지와 수정 기능을 바로 써봐. Bugbot이 코드베이스에서 흔한 문제를 자동으로 찾아내고 해결해줘.

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/bugbot.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=20d841dfc7837445103a933dab18b470" alt="Bugbot 코드 리뷰" data-og-width="1390" width="1390" data-og-height="913" height="913" data-path="images/account/team/bugbot.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/bugbot.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=975f5e3f9f9a0334c8a5bcc12faf72be 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/bugbot.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=17099f8bbe0701750d0ba212879d8a93 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/bugbot.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=041c82a4c3bada0524527609dfc134a4 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/bugbot.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=90ac57ea38768ace4b9404476fafdf32 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/bugbot.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=5785673a93f899ccca7b70e7a3752ef7 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/bugbot.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=a1a1dc51872967e392e10d6b85c31a04 2500w" />
</Frame>

<div id="active-directory-management">
  ## Active Directory 관리
</div>

엔터프라이즈 팀이라면 Active Directory 통합으로 사용자 인증과 접근 권한을 관리해. SSO랑 사용자 프로비저닝을 설정해.

<div id="usage">
  ## 사용량
</div>

AI 요청, 모델 사용, 리소스 소비까지 포함한 상세 사용 지표를 추적해. 팀원과 프로젝트 전반의 사용량을 모니터링해.

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/usage.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=8744e41430d162199d85ca8e966c91cd" data-og-width="1390" width="1390" data-og-height="913" height="913" data-path="images/account/team/usage.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/usage.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=bc43eaaeca3c2a531a56243037a7a53f 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/usage.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=34700d63fabf072e9906aab74f79f7d9 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/usage.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=7f2bcdb271d6b30e333374c798638989 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/usage.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=424bd0eeda69200668f8f0b86dc360bf 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/usage.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=f0e716c72f01a3297a53a5b63d191ef4 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/usage.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=ffa574322508a07cc5ab867b331b6d35 2500w" />
</Frame>

<div id="billing-invoices">
  ## 결제 및 청구서
</div>

구독을 관리하고, 결제 수단을 업데이트하고, 청구 내역을 확인해. 청구서를 다운로드하고 사용량 기반 요금 설정을 관리해.

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/billing.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=d76d20a7fafc6ed2135f2f9c78ec6c2d" data-og-width="1390" width="1390" data-og-height="913" height="913" data-path="images/account/team/billing.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/billing.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=45501f34dd144ecd74e982fe5f8f8364 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/billing.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=19860b61e083a8550cb3caa16bdb1ba0 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/billing.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=7005bae381a362b39980a49113ca367c 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/billing.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e47c9ee55e3699ba46429b0ac0563b5b 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/billing.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=039106fd5ff42f2e343b2b853614e7e7 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/billing.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e598f83559985558f5825a3da25bb554 2500w" />
</Frame>



# 엔터프라이즈 설정
Source: https://docs.cursor.com/ko/account/teams/enterprise-settings

조직의 Cursor 설정을 중앙에서 관리하기

<div id="enterprise-settings">
  # 엔터프라이즈 설정
</div>

조직의 요구에 맞게 기기 관리 솔루션으로 Cursor의 특정 기능을 중앙에서 관리할 수 있어. Cursor 정책을 지정하면 그 값이 사용자 기기에서 대응하는 Cursor 설정을 덮어써.

'Extensions: Allowed' 설정이 조직에서 관리되고 있음을 보여주는 설정 편집기.

현재 Cursor는 다음 관리자 제어 기능을 관리할 수 있는 정책을 제공해:

| Policy            | Description                                        | Cursor setting           | Available since |
| ----------------- | -------------------------------------------------- | ------------------------ | --------------- |
| AllowedExtensions | 설치할 수 있는 확장을 제어해.                                  | extensions.allowed       | 1.2             |
| AllowedTeamId     | 로그인할 수 있는 팀 ID를 제어해. 인가되지 않은 팀 ID의 사용자는 강제로 로그아웃돼. | cursorAuth.allowedTeamId | 1.3             |

<div id="configure-allowed-extensions">
  ## 허용된 확장 기능 구성
</div>

`extensions.allowed` Cursor 설정은 설치 가능한 확장 기능을 제어해. 퍼블리셔 이름을 키로, 해당 퍼블리셔의 확장 기능 허용 여부를 나타내는 불리언 값을 가지는 JSON 객체를 받지.

예를 들어 `extensions.allowed`를 `{"anysphere": true, "github": true}`로 설정하면 Anysphere와 GitHub 퍼블리셔의 확장 기능이 허용되고, `{"anysphere": false}`로 설정하면 Anysphere 확장 기능이 차단돼.

조직 차원에서 허용할 확장 기능을 중앙에서 관리하려면 디바이스 관리 솔루션으로 `AllowedExtensions` 정책을 구성해. 이 정책은 사용자 디바이스의 `extensions.allowed` 설정을 무시하고 덮어써. 정책 값은 허용할 퍼블리셔를 정의하는 JSON 문자열이야.

Cursor의 확장 기능에 대해 더 자세히 알고 싶다면 확장 기능 문서를 참고해.

<div id="configure-allowed-team-ids">
  ## 허용된 팀 ID 구성하기
</div>

`cursorAuth.allowedTeamId` Cursor 설정은 Cursor에 로그인할 수 있는 팀 ID를 제어해. 이 설정은 액세스가 허용된 팀 ID를 콤마로 구분한 목록을 받아.

예를 들어, `cursorAuth.allowedTeamId`를 `"1,3,7"`로 설정하면 해당 팀 ID에 속한 사용자만 로그인할 수 있어.

허용 목록에 없는 팀 ID로 로그인을 시도하면:

* 즉시 강제로 로그아웃돼
* 오류 메시지가 표시돼
* 유효한 팀 ID를 사용할 때까지 애플리케이션이 추가 인증 시도를 막아

조직 차원에서 허용된 팀 ID를 중앙에서 관리하려면, 디바이스 관리 솔루션에서 `AllowedTeamId` 정책을 구성해. 이 정책은 사용자 디바이스의 `cursorAuth.allowedTeamId` 설정을 재정의해. 정책 값은 허용된 팀 ID를 콤마로 구분한 문자열이야.

<div id="group-policy-on-windows">
  ## Windows의 그룹 정책
</div>

Cursor는 Windows 레지스트리 기반 그룹 정책을 지원해. 정책 정의를 설치하면 관리자는 로컬 그룹 정책 편집기로 정책 값을 관리할 수 있어.

정책을 추가하려면:

1. `AppData\Local\Programs\cursor\policies`에서 ADMX와 ADML 정책 파일을 복사해.
2. ADMX 파일은 `C:\Windows\PolicyDefinitions` 디렉터리에, ADML 파일은 `C:\Windows\PolicyDefinitions\<your-locale>\` 디렉터리에 붙여넣어.
3. 로컬 그룹 정책 편집기를 다시 시작해.
4. 로컬 그룹 정책 편집기에서 적절한 정책 값을 설정해 (예: `AllowedExtensions` 정책에 `{"anysphere": true, "github": true}`).

정책은 Computer 수준과 User 수준 모두에 설정할 수 있어. 둘 다 설정되면 Computer 수준이 우선해. 정책 값이 설정되면, 그 값이 어떤 수준(기본값, 사용자, 워크스페이스 등)에서 구성된 Cursor 설정 값을 재정의해.

<div id="configuration-profiles-on-macos">
  ## macOS의 구성 프로파일
</div>

구성 프로파일은 macOS 기기의 설정을 관리해. 프로파일은 사용 가능한 정책에 대응하는 키-값 쌍으로 이뤄진 XML 파일이야. 이 프로파일은 Mobile Device Management(MDM) 솔루션으로 배포하거나 수동으로 설치할 수 있어.

<Accordion title="예시 .mobileconfig 파일">
  macOS용 예시 `.mobileconfig` 파일은 아래와 같아:

  ```
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  	<dict>
  		<key>PayloadContent</key>
  		<array>
  			<dict>
  				<key>PayloadDisplayName</key>
  				<string>Cursor</string>
  				<key>PayloadIdentifier</key>
  				<string>com.todesktop.230313mzl4w4u92.J6B5723A-6539-4F31-8A4E-3CC96E51F48C</string>
  				<key>PayloadType</key>
  				<string>com.todesktop.230313mzl4w4u92</string>
  				<key>PayloadUUID</key>
  				<string>J6B5723A-6539-4F31-8A4E-3CC96E51F48C</string>
  				<key>PayloadVersion</key>
  				<integer>1</integer>
  				<key>AllowedExtensions</key>
  				<string>{"anysphere":true}</string>
  				<key>AllowedTeamId</key>
  				<string>1,2</string>
  			</dict>
  		</array>
  		<key>PayloadDescription</key>
  		<string>This profile manages Cursor.</string>
  		<key>PayloadDisplayName</key>
  		<string>Cursor</string>
  		<key>PayloadIdentifier</key>
  		<string>com.todesktop.230313mzl4w4u92</string>
  		<key>PayloadOrganization</key>
  		<string>Anysphere</string>
  		<key>PayloadType</key>
  		<string>Configuration</string>
  		<key>PayloadUUID</key>
  		<string>F2C1A7B3-9D4E-4B2C-8E1F-7A6C5D4B3E2F</string>
  		<key>PayloadVersion</key>
  		<integer>1</integer>
  		<key>TargetDeviceType</key>
  		<integer>5</integer>
  	</dict>
  </plist>
  ```
</Accordion>

<div id="string-policies">
  ### 문자열 정책
</div>

아래 예시는 `AllowedExtensions` 정책 구성을 보여줘. 샘플 파일에서 이 정책 값은 비어 있는 상태로 시작해(허용된 확장자 없음).

```
<key>허용된 확장자</key>
<string></string>
```

`<string>` 태그 사이에 정책을 정의하는 적절한 JSON 문자열을 추가해.

```
<key>AllowedExtensions</key>
<string>{"anysphere": true, "github": true}</string>
```

`AllowedTeamId` 정책에는 팀 ID를 쉼표로 구분해 나열해줘:

```
<key>AllowedTeamId</key>
<string>1,3,7</string>
```

**중요:** 제공된 `.mobileconfig` 파일은 해당 버전의 Cursor에서 사용 가능한 **모든** 정책을 초기화해. 필요 없는 정책은 삭제해.

샘플 `.mobileconfig`에서 정책을 편집하거나 제거하지 않으면, 그 정책은 기본(제한적인) 값으로 강제 적용돼.

Finder에서 `.mobileconfig` 프로파일을 더블 클릭한 다음, 시스템 설정의 **일반** > **기기 관리**에서 활성화해서 구성 프로파일을 수동으로 설치해. 시스템 설정에서 프로파일을 제거하면 Cursor에서 해당 정책도 제거돼.

구성 프로파일에 대한 자세한 내용은 Apple 문서를 참고해.

<div id="additional-policies">
  ## 추가 정책
</div>

목표는 현재 Cursor 설정을 정책으로 끌어올리고 기존 설정을 최대한 따르면서, 이름과 동작의 일관성을 유지하는 거야. 더 많은 정책을 추가해 달라는 요청이 있다면 Cursor GitHub 저장소에 이슈를 열어줘. 팀이 해당 동작을 이미 제어하는 설정이 있는지, 아니면 원하는 동작을 제어할 새 설정을 만들어야 하는지 판단할게.

<div id="frequently-asked-questions">
  ## 자주 묻는 질문
</div>

<div id="does-cursor-support-configuration-profiles-on-linux">
  ### Cursor는 Linux에서 구성 프로필을 지원해?
</div>

Linux 지원은 로드맵에 없어. Linux에서 구성 프로필에 관심이 있다면 Cursor GitHub 리포지토리에 이슈를 열고 네 사용 사례를 자세히 공유해줘.



# 구성원 & 역할
Source: https://docs.cursor.com/ko/account/teams/members

팀 구성원과 역할 관리

Cursor 팀에는 세 가지 역할이 있어.

<div id="roles">
  ## 역할
</div>

**Members**는 Cursor의 Pro 기능에 접근할 수 있는 기본 역할이야.

* Cursor의 Pro 기능 전체 사용 가능
* 결제 설정이나 관리자 대시보드에는 접근 불가
* 본인 사용량과 남은 사용량 기반 예산 확인 가능

**Admins**는 팀 관리와 보안 설정을 담당해.

* Pro 기능 전체 사용 가능
* 멤버 추가/삭제, 역할 변경, SSO 설정
* 사용량 기반 과금과 지출 한도 설정
* 팀 분석 접근 가능

**Unpaid Admins**는 유료 좌석 없이 팀을 관리해 — Cursor에 직접 접근할 필요가 없는 IT나 재무 담당자에게 딱 좋아.

* 과금 대상 아님, Pro 기능 없음
* Admins와 동일한 관리 권한

<Info>Unpaid Admins는 팀에 최소 한 명의 유료 사용자가 있어야 해.</Info>

<div id="role-comparison">
  ## 역할 비교
</div>

<div className="full-width-table">
  | 권한/기능        | Member | Admin | Unpaid Admin |
  | ------------ | :----: | :---: | :----------: |
  | Cursor 기능 사용 |    ✓   |   ✓   |              |
  | 멤버 초대        |    ✓   |   ✓   |       ✓      |
  | 멤버 제거        |        |   ✓   |       ✓      |
  | 사용자 역할 변경    |        |   ✓   |       ✓      |
  | 관리자 대시보드     |        |   ✓   |       ✓      |
  | SSO/보안 설정    |        |   ✓   |       ✓      |
  | 결제 관리        |        |   ✓   |       ✓      |
  | 분석 보기        |        |   ✓   |       ✓      |
  | 접근 관리        |        |   ✓   |       ✓      |
  | 사용량 제한 설정    |        |   ✓   |       ✓      |
  | 유료 시트 필요     |    ✓   |   ✓   |              |
</div>

<div id="managing-members">
  ## 멤버 관리
</div>

모든 팀 멤버가 다른 사람을 초대할 수 있어. 지금은 초대를 따로 제한하지 않아.

<div id="add-member">
  ### 멤버 추가
</div>

멤버를 추가하는 방법은 세 가지야:

1. **이메일 초대**

   * `Invite Members` 클릭
   * 이메일 주소 입력
   * 사용자에게 이메일 초대 전송

2. **초대 링크**

   * `Invite Members` 클릭
   * `Invite Link` 복사
   * 팀 멤버와 공유

3. **SSO**
   * [admin dashboard](/ko/account/teams/sso)에서 SSO 설정
   * SSO 이메일로 로그인하면 자동으로 팀에 합류

<Warning>
  초대 링크는 만료까지 기간이 길어서, 링크만 있으면 누구나 합류할 수 있어.
  링크를 폐기하거나 [SSO](/ko/account/teams/sso)를 사용해
</Warning>

<div id="remove-member">
  ### 멤버 제거
</div>

관리자는 컨텍스트 메뉴 → "Remove"로 언제든 멤버를 제거할 수 있어. 멤버가 크레딧을 사용했다면 과금 주기가 끝날 때까지 해당 좌석은 유지돼.

<div id="change-role">
  ### 역할 변경
</div>

관리자는 컨텍스트 메뉴를 클릭한 다음 "Change role" 옵션으로 다른 멤버의 역할을 변경할 수 있어.<br />

항상 최소 한 명의 Admin과 한 명의 유료 멤버가 팀에 있어야 해.

## 보안 & SSO

SAML 2.0 Single Sign-On(SSO)은 Team 플랜에서 사용할 수 있어. 주요 기능은 다음과 같아:

* SSO 연결 구성 ([자세히 알아보기](/ko/account/teams/sso))
* 도메인 소유권 확인 설정
* 사용자 자동 등록
* SSO 의무 적용 옵션
* 아이덴티티 제공자 연동(Okta 등)

<Note>
  <p className="!mb-0">SSO를 사용하려면 도메인 소유권 확인이 필요해.</p>
</Note>

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=76608c26daf1f9ab2bbc2c4ccb156c0e" style={{ padding: `32px 64px`, backgroundColor: "#0c0c0c" }} data-og-width="802" width="802" data-og-height="440" height="440" data-path="images/account/sso-settings.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=334dc1fc107338d19ec7b0052e7ea0e4 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=543b3d868c19960a5fb4c526d9895bd3 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=a06655178ba10f6a72919e9f7d598191 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e280fc911306fe8d3b8e90b7221b0c11 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=ffd8f2c0168e2ac4f95431062b226021 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1c17e4eac666b663d676ce874f1c4ba5 2500w" />
</Frame>

<div id="usage-controls">
  ## 사용 관리
</div>

사용 설정에서 다음을 수행할 수 있어:

* 사용량 기반 과금 활성화
* 프리미엄 모델에 대해 활성화
* 관리자 전용 변경만 허용
* 월별 지출 한도 설정
* 팀 전체 사용 현황 모니터링

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/usage-based-pricing.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e8149f830c27308af1bcc329c25e38b5" style={{ backgroundColor: "#0c0c0c" }} data-og-width="1668" width="1668" data-og-height="1160" height="1160" data-path="images/account/usage-based-pricing.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/usage-based-pricing.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=bc308a967251694ad7b03189c1083c61 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/usage-based-pricing.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=ddc293e19fa993e65be8c09ced649b4f 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/usage-based-pricing.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=3a4df7d48d75c6166ab215550a641ca6 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/usage-based-pricing.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=f9051947c802ae54fd964196c50a3701 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/usage-based-pricing.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=ed775e3e98611ead1b938aedaf917f11 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/usage-based-pricing.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=b26f86bce94dc981d3cf71853a965374 2500w" />
</Frame>

<div id="billing">
  ## 결제
</div>

팀원을 추가할 때:

* 멤버나 Admin 한 명 추가할 때마다 과금 좌석이 1개 늘어나 (참고: [pricing](https://cursor.com/pricing))
* 신규 멤버는 해당 결제 기간에 남은 기간만큼 일할로 청구돼
* Unpaid Admin 좌석은 과금에 포함되지 않아

월 중에 추가된 좌석은 사용한 일수만큼만 청구돼. 크레딧을 사용한 멤버를 제거해도, 그 좌석은 결제 사이클이 끝날 때까지 유지되고 일할 환불은 없어.

역할 변경(예: Admin → Unpaid Admin)은 변경일 기준으로 과금이 조정돼. 월간 또는 연간 결제를 선택해.

월간/연간 갱신은 멤버 변경과 상관없이 최초 가입일에 진행돼.

<div id="switch-to-yearly-billing">
  ### 연간 결제로 전환
</div>

월간에서 연간으로 전환하면 **20%** 절약:

1. [Dashboard](https://cursor.com/dashboard)로 이동
2. Account 섹션에서 "Advanced" 클릭 후 "Upgrade to yearly billing" 선택

<Note>
  월간 → 연간 전환은 대시보드에서만 가능해.
  연간 → 월간 전환은 [hi@cursor.com](mailto:hi@cursor.com)으로 연락해.
</Note>



# SCIM
Source: https://docs.cursor.com/ko/account/teams/scim

사용자와 그룹의 자동 관리용 SCIM 프로비저닝 설정

<div id="overview">
  ## 개요
</div>

SCIM 2.0 프로비저닝은 아이덴티티 제공자를 통해 팀 구성원과 디렉터리 그룹을 자동으로 관리해. SSO가 활성화된 Enterprise 플랜에서 사용할 수 있어.

<product_visual type="screenshot">
  Active Directory Management 구성으로 표시된 SCIM 설정 대시보드
</product_visual>

<div id="prerequisites">
  ## 사전 준비 사항
</div>

* Cursor Enterprise 플랜
* SSO가 먼저 구성되어 있어야 함 — **SCIM에는 활성화된 SSO 연결이 필요함**
* 아이덴티티 제공자(Okta, Azure AD 등)에 대한 관리자 권한
* Cursor 조직에 대한 관리자 권한

<div id="how-it-works">
  ## 동작 방식
</div>

<div id="user-provisioning">
  ### 사용자 프로비저닝
</div>

IDP의 SCIM 애플리케이션에 할당되면 사용자는 자동으로 Cursor에 추가돼. 할당 해제되면 제거돼. 변경 사항은 실시간으로 동기화돼.

<div id="directory-groups">
  ### 디렉터리 그룹
</div>

디렉터리 그룹과 멤버십은 IDP에서 동기화돼. 그룹과 사용자 관리는 IDP에서만 해야 해 — Cursor는 이 정보를 읽기 전용으로 보여줘.

<div id="spend-management">
  ### 지출 관리
</div>

디렉터리 그룹별로 사용자당 지출 한도를 다르게 설정해. 디렉터리 그룹 한도가 팀 수준 한도보다 우선이야. 여러 그룹에 속한 사용자는 적용 가능한 한도 중 가장 높은 한도가 적용돼.

<div id="setup">
  ## 설정
</div>

<Steps>
  <Step title="SSO가 구성되어 있는지 확인">
    SCIM을 쓰려면 먼저 SSO가 설정돼 있어야 해. 아직 SSO를 안 했다면,
    진행하기 전에 [SSO 설정 가이드](/ko/account/teams/sso)를 따라줘.
  </Step>

  <Step title="Active Directory Management에 접근">
    관리자 계정으로
    [cursor.com/dashboard?tab=active-directory](https://www.cursor.com/dashboard?tab=active-directory)
    로 이동하거나, 대시보드 설정에서
    "Active Directory Management" 탭을 선택해.
  </Step>

  <Step title="SCIM 설정 시작">
    SSO가 확인되면 단계별 SCIM 설정 링크가 보여. 이걸 클릭해서
    설정 마법사를 시작해.
  </Step>

  <Step title="아이덴티티 제공자에서 SCIM 구성">
    아이덴티티 제공자에서: - SCIM 애플리케이션 생성 또는 구성 - Cursor가 제공한 SCIM 엔드포인트와 토큰 사용 - 사용자 및 그룹 푸시 프로비저닝 활성화 - 연결 테스트
  </Step>

  <Step title="지출 한도 구성(선택)">
    Cursor의 Active Directory Management 페이지로 돌아와서: - 동기화된
    디렉터리 그룹 확인 - 필요에 따라 특정 그룹에 사용자별 지출 한도 설정 -
    여러 그룹에 속한 사용자에게 적용되는 한도 검토
  </Step>
</Steps>

<div id="identity-provider-setup">
  ### 아이덴티티 제공자 설정
</div>

제공자별 설정 방법은 아래를 참고해:

<Card title="Identity Provider Guides" icon="book" href="https://workos.com/docs/integrations">
  Okta, Azure AD, Google Workspace 등 설정 안내.
</Card>

<div id="managing-users-and-groups">
  ## 사용자와 그룹 관리
</div>

<Warning>
  모든 사용자와 그룹 관리는 IdP(아이덴티티 프로바이더)에서만 관리해야 해.
  IdP에서 변경한 내용은 자동으로 Cursor랑 동기화되지만,
  Cursor에서 사용자나 그룹을 직접 수정할 수는 없어.
</Warning>

<div id="user-management">
  ### 사용자 관리
</div>

* IdP에서 SCIM 애플리케이션에 할당해서 사용자를 추가해
* SCIM 애플리케이션에서 할당 해제해서 사용자를 제거해
* 사용자 프로필 변경(이름, 이메일)은 IdP에서 자동으로 동기화돼

<div id="group-management">
  ### 그룹 관리
</div>

* 디렉터리 그룹은 IdP에서 자동으로 동기화돼
* 그룹 멤버십 변경은 실시간으로 반영돼
* 그룹을 활용해 사용자를 조직하고 서로 다른 지출 한도를 설정해

<div id="spend-limits">
  ### 지출 한도
</div>

* 각 디렉터리 그룹마다 사용자별 한도를 다르게 설정해
* 사용자는 속한 그룹 중 가장 높은 지출 한도를 상속받아
* 그룹 한도가 팀 전체 기본 사용자별 한도보다 우선이야

<div id="faq">
  ## FAQ
</div>

<div id="why-isnt-scim-management-showing-up-in-my-dashboard">
  ### 내 대시보드에 SCIM 관리가 안 보이는 이유가 뭐야?
</div>

SCIM을 설정하기 전에 SSO가 제대로 구성돼 있고 정상 작동하는지 확인해. SCIM은 작동하려면 활성 SSO 연결이 필요해.

<div id="why-arent-users-syncing">
  ### 사용자 동기화가 안 되는 이유가 뭐야?
</div>

아이덴티티 프로바이더에서 사용자가 SCIM 애플리케이션에 할당돼 있는지 확인해. 사용자가 Cursor에 나타나려면 명시적으로 할당돼 있어야 해.

<div id="why-arent-groups-appearing">
  ### 그룹이 안 보이는 이유가 뭐야?
</div>

아이덴티티 프로바이더의 SCIM 설정에서 그룹 푸시 프로비저닝이 활성화돼 있는지 확인해. 그룹 동기화는 사용자 동기화와 별도로 설정해야 해.

<div id="why-arent-spend-limits-applying">
  ### 지출 한도가 적용되지 않는 이유가 뭐야?
</div>

아이덴티티 프로바이더에서 사용자가 기대한 그룹에 제대로 할당돼 있는지 확인해. 적용되는 지출 한도는 그룹 멤버십으로 결정돼.

<div id="can-i-manage-scim-users-and-groups-directly-in-cursor">
  ### Cursor에서 SCIM 사용자와 그룹을 직접 관리할 수 있어?
</div>

아니. 모든 사용자와 그룹 관리는 아이덴티티 프로바이더에서만 해야 해. Cursor는 이 정보를 읽기 전용으로 표시해.

<div id="how-quickly-do-changes-sync">
  ### 변경 사항은 얼마나 빨리 동기화돼?
</div>

아이덴티티 프로바이더에서 이뤄진 변경 사항은 실시간으로 Cursor에 동기화돼. 대량 일괄 작업은 잠깐 지연될 수 있어.



# 시작하기
Source: https://docs.cursor.com/ko/account/teams/setup

Cursor 팀 만들기 및 설정하기

<div id="cursor-for-teams">
  ## Cursor for Teams
</div>

Cursor는 개인도 팀도 잘 맞아. Teams 플랜은 조직에 필요한 툴을 제공해: SSO, 팀 관리, 액세스 제어, 사용량 분석.

<div id="creating-a-team">
  ## 팀 만들기
</div>

다음 단계를 따라 팀을 만들어:

<Steps>
  <Step title="Teams 플랜 설정">
    팀을 만들려면 이렇게 해:

    1. **새 사용자**: [cursor.com/team/new-team](https://cursor.com/team/new-team)에서 새 계정이랑 팀 만들기
    2. **기존 사용자**: [dashboard](/ko/account/dashboard)로 가서 "Upgrade to Teams" 클릭
  </Step>

  <Step title="팀 정보 입력">
    팀 이름이랑 결제 주기를 선택해

    <Frame>
      <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/new-team.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=3b9df20d032b544dcbc0343d9ddf056f" data-og-width="3456" width="3456" data-og-height="2158" height="2158" data-path="images/account/team/new-team.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/new-team.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=b81f3241069a8a0fb9278b6a2e246057 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/new-team.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=c26976bf06297d36ec9224ec1496a630 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/new-team.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=fed5c7c95914ff47cfceae81f1441208 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/new-team.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=0dc5986368419ef54f45803547741cfe 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/new-team.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=4eb38a9618399ddadbf7596b185d2732 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/team/new-team.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1c7d720a1e20d2aa23463a1b9001d545 2500w" />
    </Frame>
  </Step>

  <Step title="멤버 초대">
    팀 멤버를 초대해. 사용자 수는 일할 계산돼—멤버로 있는 기간만 비용이 청구돼.

    <Frame>
      <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/invite-members.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=bbd84dd96a7003415c2d2f038b1aaa77" style={{ paddingLeft: 16, paddingRight: 16, backgroundColor: '#0c0c0c' }} data-og-width="880" width="880" data-og-height="422" height="422" data-path="images/account/invite-members.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/invite-members.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=988e36ee874f704dfaae1b0a69ed2f84 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/invite-members.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=c0f85aacd3be59e11b1bfd05f9e5d6cd 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/invite-members.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=411456e375f8c406ad2972965e0b549e 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/invite-members.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=57ae04799be300a7e61464490344146f 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/invite-members.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=2faa0cf8ed56865c19916e33fde97900 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/invite-members.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=0bdb5040f44338e748246b4f1ddf2ddf 2500w" />
    </Frame>
  </Step>

  <Step title="SSO 활성화(선택)">
    보안이랑 자동 온보딩을 위해 [SSO](/ko/account/teams/sso)를 활성화해.

    <Frame>
      <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=76608c26daf1f9ab2bbc2c4ccb156c0e" data-og-width="802" width="802" data-og-height="440" height="440" data-path="images/account/sso-settings.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=334dc1fc107338d19ec7b0052e7ea0e4 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=543b3d868c19960a5fb4c526d9895bd3 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=a06655178ba10f6a72919e9f7d598191 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e280fc911306fe8d3b8e90b7221b0c11 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=ffd8f2c0168e2ac4f95431062b226021 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1c17e4eac666b663d676ce874f1c4ba5 2500w" />
    </Frame>
  </Step>
</Steps>

<div id="faq">
  ## FAQ
</div>

<AccordionGroup>
  <Accordion title="우리 팀이 Zscaler / 프록시 / VPN을 써. Cursor가 잘 동작할까?">
    Cursor는 기본적으로 HTTP/2를 사용해. 일부 프록시나 VPN은 이걸 막을 수 있어.

    설정에서 HTTP/1.1 폴백을 켜서 HTTP/1.1로 사용해.
  </Accordion>

  <Accordion title="회사용 라이선스는 어떻게 구매해?">
    Cursor는 좌석 수가 아니라 활성 사용자 기준으로 과금해. 언제든 사용자를 추가하거나 제거할 수 있고, 새 멤버는 남은 기간에 대해 비례 청구돼. 제거된 사용자가 크레딧을 사용했다면, 그 좌석은 청구 주기 종료 시점까지 점유돼.

    갱신 날짜는 그대로야.
  </Accordion>

  <Accordion title="내가 Cursor를 쓰지 않을 때 팀을 어떻게 설정해?">
    라이선스 없이 관리하려면 너 자신을 [Unpaid Admin](/ko/account/teams/members)으로 설정해.

    <Warning>
      팀에는 최소 한 명의 유료 멤버가 필요해. 먼저 설정하고, 멤버를 초대한 다음, 청구 전에 역할을 바꿔도 돼.
    </Warning>
  </Accordion>

  <Accordion title="회사 MDM에 Cursor를 어떻게 추가해?">
    모든 플랫폼용 다운로드 링크는 [cursor.com/downloads](https://cursor.com/downloads)에서 확인할 수 있어.

    MDM 안내:

    * [Omnissa Workspace ONE](https://docs.omnissa.com/bundle/MobileApplicationManagementVSaaS/page/DeployInternalApplications.html) (구 VMware)
    * [Microsoft Intune (Windows)](https://learn.microsoft.com/en-us/mem/intune-service/apps/apps-win32-app-management)
    * [Microsoft Intune (Mac)](https://learn.microsoft.com/en-us/mem/intune-service/apps/lob-apps-macos-dmg)
    * [Kandji MDM](https://support.kandji.io/kb/custom-apps-overview)
  </Accordion>
</AccordionGroup>



# SSO
Source: https://docs.cursor.com/ko/account/teams/sso

팀의 Single Sign-On 설정하기

<div id="overview">
  ## 개요
</div>

SAML 2.0 SSO는 Business 플랜에서 추가 비용 없이 제공돼. 기존 IdP(Identity Provider)를 사용해서 별도의 Cursor 계정 없이 팀원을 인증할 수 있어.

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=76608c26daf1f9ab2bbc2c4ccb156c0e" style={{ padding: 32, backgroundColor: "#0c0c0c" }} data-og-width="802" width="802" data-og-height="440" height="440" data-path="images/account/sso-settings.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=334dc1fc107338d19ec7b0052e7ea0e4 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=543b3d868c19960a5fb4c526d9895bd3 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=a06655178ba10f6a72919e9f7d598191 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e280fc911306fe8d3b8e90b7221b0c11 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=ffd8f2c0168e2ac4f95431062b226021 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/sso-settings.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1c17e4eac666b663d676ce874f1c4ba5 2500w" />
</Frame>

<div id="prerequisites">
  ## 사전 준비 사항
</div>

* Cursor Team 플랜
* ID 공급자(예: Okta)에 대한 관리자 권한
* Cursor 조직에 대한 관리자 권한

<div id="configuration-steps">
  ## 구성 단계
</div>

<Steps>
  <Step title="Cursor 계정에 로그인">
    관리자 계정으로 [cursor.com/dashboard?tab=settings](https://www.cursor.com/dashboard?tab=settings)로 이동해.
  </Step>

  <Step title="SSO 구성 찾기">
    "Single Sign-On (SSO)" 섹션을 찾아 펼쳐.
  </Step>

  <Step title="설정 시작하기">
    "SSO Provider Connection settings" 버튼을 눌러 SSO 설정을 시작하고, 안내 마법사를 따라가.
  </Step>

  <Step title="IdP 구성">
    네 identity provider(예: Okta)에서:

    * 새 SAML 애플리케이션 만들기
    * Cursor 정보로 SAML 설정 구성하기
    * Just-in-Time(JIT) 프로비저닝 설정하기
  </Step>

  <Step title="도메인 인증">
    "Domain verification settings" 버튼을 눌러 Cursor에서 사용자 도메인을 인증해.
  </Step>
</Steps>

<div id="identity-provider-setup-guides">
  ### Identity Provider 설정 가이드
</div>

제공자별 설정 방법은 여기에서 확인해:

<Card title="Identity Provider Guides" icon="book" href="https://workos.com/docs/integrations">
  Okta, Azure AD, Google Workspace 등 설정 가이드.
</Card>

<div id="additional-settings">
  ## 추가 설정
</div>

* 관리자 대시보드에서 SSO 강제 적용 관리
* 새 사용자는 SSO로 로그인하면 자동으로 등록돼
* 아이덴티티 제공자를 통해 사용자 관리 수행

<div id="troubleshooting">
  ## 문제 해결
</div>

문제가 생기면:

* Cursor에서 도메인이 인증되었는지 확인해줘
* SAML 속성이 올바르게 매핑됐는지 확인해줘
* 관리자 대시보드에서 SSO가 활성화돼 있는지 확인해줘
* 아이덴티티 제공자와 Cursor에서 이름(First name)과 성(Last name)이 일치하는지 확인해줘
* 위의 제공자별 가이드를 확인해봐
* 문제가 계속되면 [hi@cursor.com](mailto:hi@cursor.com)으로 연락해줘



# 업데이트 접근 권한
Source: https://docs.cursor.com/ko/account/update-access

업데이트 수신 빈도를 선택해

export const Kbd = ({children, tooltip, os}) => {
  const keysInput = typeof children === 'string' && children.trim() !== '' ? children : null;
  if (!keysInput) {
    return null;
  }
  const isModifier = key => {
    const modifiers = ['⌘', '⇧', '⌥', '⌃', '⏎', '⌫', '⌦', '⎋', '⇥', '⌁', '←', '→', '↑', '↓', 'Ctrl', 'Shift', 'Alt', 'Cmd', 'Opt', 'Return', 'Backspace', 'Delete', 'Escape', 'Tab', 'Space', 'Enter', 'Esc', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down'];
    return modifiers.includes(key.trim());
  };
  const capitalizeFirstLetter = string => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  const isMac = os ? os.toLowerCase() === 'mac' || os.toLowerCase() === 'macos' : typeof navigator !== 'undefined' && (navigator.platform.toUpperCase().indexOf('MAC') >= 0 || navigator.userAgent.toUpperCase().indexOf('MAC') >= 0);
  const convertToSymbols = shortcut => {
    if (isMac) {
      return shortcut.replace(/⌘|Cmd|CMD/gi, '⌘').replace(/⌥|Opt|OPT/gi, '⌥').replace(/⌃|Ctrl/gi, '⌃').replace(/⇧|Shift/gi, '⇧').replace(/⏎|Return/gi, '⏎').replace(/⌫|Backspace/gi, '⌫').replace(/⌦|Delete/gi, '⌦').replace(/␛|Escape/gi, '␛').replace(/⇥|Tab/gi, '⇥').replace(/⌁|Space/gi, '⌁').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, '←').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, '→').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, '↑').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, '↓');
    } else {
      const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Ctrl').replace(/⌥|Opt|OPT/gi, 'Alt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Enter').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Esc').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
      const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
      return keyList.join('+');
    }
  };
  const convertToReadableText = shortcut => {
    const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Cmd').replace(/⌥|Opt|OPT/gi, 'Opt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Return').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Escape').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
    const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
    return keyList.map(key => {
      const trimmedKey = key.trim();
      return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
    }).join('+');
  };
  const displayShortcut = convertToSymbols(keysInput);
  const tooltipText = isMac ? tooltip ? `${convertToReadableText(keysInput)}: ${tooltip}` : convertToReadableText(keysInput) : tooltip || null;
  const processedKeys = isMac ? displayShortcut.split(/[\+\s]+/).filter(key => key.trim()).map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('') : displayShortcut.split('+').map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('+');
  return tooltipText ? <Tooltip tip={tooltipText}>
      <kbd>
        {processedKeys}
      </kbd>
    </Tooltip> : <kbd>
      {processedKeys}
    </kbd>;
};

Cursor에는 업데이트 채널이 두 가지 있어.

<Tabs>
  <Tab title="Default">
    검증된 릴리스를 제공하는 기본 업데이트 채널이야.

    * 안정적인 릴리스
    * 프리릴리스 테스트에서 나온 버그 수정
    * 모든 사용자의 기본값
    * 팀 사용자가 선택할 수 있는 유일한 옵션

    <Note>
      팀 및 비즈니스 계정은 Default 모드를 사용해.
    </Note>
  </Tab>

  <Tab title="Early Access">
    새로운 기능이 포함된 프리릴리스 버전이야.

    <Warning>
      Early Access 빌드는 버그나 안정성 문제가 있을 수 있어.
    </Warning>

    * 개발 중인 기능을 미리 사용
    * 버그가 포함될 수 있음
    * 팀 계정에는 제공되지 않음
  </Tab>
</Tabs>

<div id="change-update-channel">
  ## 업데이트 채널 변경
</div>

1. **설정 열기**: <Kbd>Cmd+Shift+J</Kbd> 누르기
2. **Beta로 이동**: 사이드바에서 Beta 선택
3. **채널 선택**: Default 또는 Early Access 선택

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/early-access.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=36c55c2deb93bc734b6ee0099a0d184c" data-og-width="1798" width="1798" data-og-height="442" height="442" data-path="images/account/early-access.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/early-access.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=624bfea7b3643f55afaa85b38b1c56e1 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/early-access.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=f32c8e59596f024223735b4f929949e0 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/early-access.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=bd8c4bf3265ab802b6188aa81a620244 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/early-access.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e8600f42cc363c61377f158972187e01 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/early-access.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=32c83b2109587d299959c2d46ce67353 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/account/early-access.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=b2c4032824d39c62a7cbada5578b1a98 2500w" />
</Frame>

Early Access 관련 이슈는 [Forum](https://forum.cursor.com)에 보고해 줘.



# Apply
Source: https://docs.cursor.com/ko/agent/apply

Apply를 사용해 채팅에서 코드 제안을 적용, 수락, 거부하는 방법을 알아보자

<div id="how-apply-works">
  ## Apply 작동 방식
</div>

Apply는 채팅에서 생성된 코드를 가져와 파일에 통합하는 데 특화된 Cursor 모델이야. 채팅 대화의 코드 블록을 처리해서 변경 사항을 코드베이스에 적용해.

Apply는 자체적으로 코드를 생성하지 않아. 코드는 채팅 모델이 만들고, Apply가 기존 파일에 통합하는 걸 담당해. 여러 파일과 대규모 코드베이스 전반의 변경도 처리할 수 있어.

<div id="apply-code-blocks">
  ## 코드 블록 적용하기
</div>

코드 블록 제안을 적용하려면 코드 블록 오른쪽 상단의 재생 버튼을 눌러.

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=634492fa2f63b4f6eada08b2a1ded47e" data-og-width="1032" width="1032" data-og-height="410" height="410" data-path="images/chat/apply.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=7dbc88cfe20429c73e627a289b17c964 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=721e2d51bdb16dbb817e19d96d93c9d9 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=8faea188ca903e58d347ddfec2c9bf6e 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=f3bc38701cab63602b54374dfaa9e024 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=fddad51f5b12c32493e2370ed326712d 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1584d431007b33a595905e23b5e1b453 2500w" />
</Frame>



# Checkpoints
Source: https://docs.cursor.com/ko/agent/chat/checkpoints

Agent 변경 후 이전 상태 저장 및 복원

Checkpoints는 Agent가 코드베이스에 가한 변경을 자동으로 스냅샷으로 저장해. 필요하면 Agent가 한 수정을 언제든 되돌릴 수 있어.

<Frame>
  <video src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/restore-checkpoint.mp4?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=7cededf7892f15a6342a81953ea0aa38" autoPlay loop muted playsInline controls data-path="images/chat/restore-checkpoint.mp4" />
</Frame>

<div id="restoring-checkpoints">
  ## 체크포인트 복원
</div>

복원하는 방법은 두 가지야:

1. **입력 박스에서**: 이전 요청에 있는 `Restore Checkpoint` 버튼을 클릭
2. **메시지에서**: 메시지에 마우스를 올린 뒤 표시되는 + 버튼을 클릭

<Warning>
  체크포인트는 버전 관리가 아니야. 영구적인 기록은 Git을 써.
</Warning>

<div id="how-they-work">
  ## 동작 방식
</div>

* Git과 분리되어 로컬에 저장됨
* 수동 편집은 제외하고 Agent 변경만 추적됨
* 자동으로 정리됨

<Note>
  수동 편집은 추적되지 않아. 체크포인트는 Agent 변경에만 써.
</Note>

<div id="faq">
  ## FAQ
</div>

<AccordionGroup>
  <Accordion title="체크포인트가 Git에 영향 줘?">
    아니. Git 히스토리랑은 별개야.
  </Accordion>

  {" "}

  <Accordion title="얼마나 오래 보관돼?">
    현재 세션이랑 최근 기록 동안. 자동으로 정리돼.
  </Accordion>

  <Accordion title="직접 만들 수 있어?">
    아니. Cursor가 자동으로 만들어.
  </Accordion>
</AccordionGroup>

{" "}



# Commands
Source: https://docs.cursor.com/ko/agent/chat/commands

재사용 가능한 워크플로를 위한 명령 정의

사용자 지정 명령은 채팅 입력창에서 간단한 `/` 프리픽스로 호출할 수 있는 재사용 가능한 워크플로를 만들 수 있게 해줘. 이런 명령을 쓰면 팀 전반의 프로세스를 표준화하고, 반복적인 작업을 더 효율적으로 처리할 수 있어.

<Frame>
    <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/commands/input.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=0d25ac517b091210da1c6eff4c8e3098" alt="Commands input example" data-og-width="1689" width="1689" data-og-height="1079" height="1079" data-path="images/chat/commands/input.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/commands/input.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=680f0cbf1491ef1303171dbd18115288 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/commands/input.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=d6a5397e565ab2c90435e6fdd2b7b27a 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/commands/input.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=ae074e2f2b26741544fd8c8ecfa529e3 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/commands/input.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=564aad432affcc04e51b624725f386ad 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/commands/input.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=5c1bd5d49babc2f08eb0efcd24ba7783 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/commands/input.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=3244c3be31c9bc704468a706c6e6b38e 2500w" />
</Frame>

<Info>
  명령은 현재 베타야. 기능과 문법은 계속 개선되는 과정에서 변경될 수 있어.
</Info>

<div id="how-commands-work">
  ## 명령어가 동작하는 방식
</div>

명령어는 두 위치에 저장할 수 있는 일반 Markdown 파일로 정의돼:

1. **프로젝트 명령어**: 네 프로젝트의 `.cursor/commands` 디렉터리에 저장됨
2. **글로벌 명령어**: 홈 디렉터리의 `~/.cursor/commands` 디렉터리에 저장됨

채팅 입력창에 `/`를 입력하면 Cursor가 두 디렉터리에서 사용 가능한 명령어를 자동으로 찾아 표시해서, 워크플로 전반에서 바로 쓸 수 있게 해줘.

<div id="creating-commands">
  ## 커맨드 만들기
</div>

1. 프로젝트 루트에 `.cursor/commands` 디렉터리를 만든다
2. 의미 있는 이름의 `.md` 파일을 추가한다 (예: `review-code.md`, `write-tests.md`)
3. 커맨드가 수행해야 할 내용을 일반 Markdown으로 작성한다
4. 채팅창에서 `/`를 입력하면 커맨드가 자동으로 표시된다

커맨드 디렉터리 구조는 대략 이렇게 될 수 있어:

```
.cursor/
└── commands/
    ├── address-github-pr-comments.md
    ├── code-review-checklist.md
    ├── create-pr.md
    ├── light-review-existing-diffs.md
    ├── onboard-new-developer.md
    ├── run-all-tests-and-fix.md
    ├── security-audit.md
    └── setup-new-feature.md
```

<div id="examples">
  ## 예시
</div>

프로젝트에서 이 명령어들을 직접 써 보면서 어떻게 작동하는지 감을 잡아봐.

<AccordionGroup>
  <Accordion title="코드 리뷰 체크리스트">
    ```markdown  theme={null}
    # 코드 리뷰 체크리스트

    ## 개요
    품질, 보안, 유지관리성을 보장하기 위한 철저한 코드 리뷰용 종합 체크리스트.

    ## 리뷰 범주

    ### 기능
    - [ ] 코드가 의도대로 동작함
    - [ ] 경계/특수 케이스가 처리됨
    - [ ] 오류 처리가 적절함
    - [ ] 명백한 버그나 로직 오류가 없음

    ### 코드 품질
    - [ ] 코드가 읽기 쉽고 구조가 잘 잡혀 있음
    - [ ] 함수가 작고 한 가지 책임에 집중함
    - [ ] 변수명이 명확하고 설명적임
    - [ ] 코드 중복이 없음
    - [ ] 프로젝트 컨벤션을 준수함

    ### 보안
    - [ ] 명백한 보안 취약점이 없음
    - [ ] 입력 검증이 구현되어 있음
    - [ ] 민감한 데이터가 적절히 처리됨
    - [ ] 하드코딩된 시크릿이 없음
    ```
  </Accordion>

  <Accordion title="보안 감사">
    ```markdown  theme={null}
    # 보안 감사

    ## 개요
    코드베이스의 취약점을 식별하고 해결하기 위한 종합 보안 점검.

    ## 단계
    1. **의존성 감사**
       - 알려진 취약점 확인
       - 구버전 패키지 업데이트
       - 서드파티 의존성 검토

    2. **코드 보안 검토**
       - 공통 취약점 확인
       - 인증/인가 검토
       - 데이터 처리 관행 점검

    3. **인프라 보안**
       - 환경 변수 검토
       - 접근 제어 확인
       - 네트워크 보안 점검

    ## 보안 체크리스트
    - [ ] 의존성 최신화 및 안전성 확보
    - [ ] 하드코딩된 시크릿 없음
    - [ ] 입력 검증 구현 완료
    - [ ] 인증 안전함
    - [ ] 인가가 올바르게 구성됨
    ```
  </Accordion>

  <Accordion title="새 기능 설정">
    ```markdown  theme={null}
    # 새 기능 설정

    ## 개요
    초기 기획부터 구현 구조까지 새 기능을 체계적으로 준비해.

    ## 단계
    1. **요구사항 정의**
       - 기능 범위와 목표를 명확히 해
       - 사용자 스토리와 승인 기준을 정리해
       - 기술적 접근 방식을 계획해

    2. **기능 브랜치 생성**
       - main/develop에서 브랜치 따와
       - 로컬 개발 환경을 준비해
       - 새 의존성을 설정해

    3. **아키텍처 설계**
       - 데이터 모델과 API를 설계해
       - UI 컴포넌트와 플로우를 계획해
       - 테스트 전략을 수립해

    ## 기능 설정 체크리스트
    - [ ] 요구사항 문서화 완료
    - [ ] 사용자 스토리 작성 완료
    - [ ] 기술적 접근 방식 계획 완료
    - [ ] 기능 브랜치 생성 완료
    - [ ] 개발 환경 준비 완료
    ```
  </Accordion>

  <Accordion title="풀 리퀘스트 생성">
    ```markdown  theme={null}
    # PR 생성

    ## 개요
    명확한 설명, 라벨, 리뷰어를 갖춘 잘 구조화된 풀 리퀘스트를 만들어.

    ## 단계
    1. **브랜치 준비**
       - 모든 변경 사항이 커밋되었는지 확인
       - 브랜치를 원격에 푸시
       - 브랜치가 main과 최신 상태인지 확인

    2. **PR 설명 작성**
       - 변경 사항을 명확하게 요약
       - 배경 및 동기 포함
       - 브레이킹 체인지가 있다면 나열
       - UI 변경이 있으면 스크린샷 추가

    3. **PR 설정**
       - 내용을 잘 드러내는 제목으로 PR 생성
       - 적절한 라벨 추가
       - 리뷰어 지정
       - 관련 이슈 링크

    ## PR 템플릿
    - [ ] 기능 A
    - [ ] 버그 수정 B
    - [ ] 단위 테스트 통과
    - [ ] 수동 테스트 완료
    ```
  </Accordion>

  <Accordion title="테스트를 실행하고 실패를 고쳐">
    ```markdown  theme={null}
    # 모든 테스트 실행 및 실패 수정

    ## 개요
    전체 테스트 스위트를 실행하고 실패를 체계적으로 수정해서 코드 품질과 기능을 보장해.

    ## 단계
    1. **테스트 스위트 실행**
       - 프로젝트의 모든 테스트를 실행해
       - 출력을 캡처하고 실패를 식별해
       - 단위 테스트와 통합 테스트를 모두 확인해

    2. **실패 분석**
       - 유형별로 분류: 플래키, 깨짐, 신규 실패
       - 영향도에 따라 수정 우선순위를 정해
       - 최근 변경과 관련된 실패인지 확인해

    3. **체계적으로 이슈 수정**
       - 가장 중요한 실패부터 시작해
       - 한 번에 하나의 이슈만 수정해
       - 각 수정 후 테스트를 다시 실행해
    ```
  </Accordion>

  <Accordion title="새 개발자 온보딩">
    ```markdown  theme={null}
    # 새 개발자 온보딩

    ## 개요
    새 개발자가 빠르게 작업을 시작하도록 돕는 종합 온보딩 프로세스.

    ## 단계
    1. **환경 설정**
       - 필수 도구 설치
       - 개발 환경 구성
       - IDE 및 확장 프로그램 설정
       - Git 및 SSH 키 설정

    2. **프로젝트 익히기**
       - 프로젝트 구조 검토
       - 아키텍처 파악
       - 핵심 문서 읽기
       - 로컬 데이터베이스 구성

    ## 온보딩 체크리스트
    - [ ] 개발 환경 준비 완료
    - [ ] 모든 테스트 통과
    - [ ] 로컬에서 애플리케이션 실행 가능
    - [ ] 데이터베이스 구성 및 정상 동작
    - [ ] 첫 PR 제출
    ```
  </Accordion>
</AccordionGroup>



# Compact
Source: https://docs.cursor.com/ko/agent/chat/compact

컴팩트 모드 인터페이스로 채팅 공간 절약

컴팩트 모드는 시각적 잡음을 줄이고 대화 공간을 최대화해서, 더 간결한 채팅 인터페이스를 제공해.

<div id="overview">
  ## 개요
</div>

컴팩트 모드를 켜면 채팅 인터페이스가 이렇게 바뀌어:

* 더 깔끔하고 미니멀한 화면을 위해 **아이콘 숨김**
* 시각적 잡음을 줄이기 위한 **diff 자동 접기**
* 대화 공간을 최대화하기 위한 **입력란 자동 접기**

이 설정은 작은 화면에서 작업할 때나 집중해서 방해 없이 채팅하고 싶을 때 특히 유용해.

<div id="before-and-after">
  ## 전후 비교
</div>

<div id="default-mode">
  ### 기본 모드
</div>

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/compact/off.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=e0f8b97ecd5201be396fcd09cec54de6" alt="모든 아이콘과 펼쳐진 요소가 보이는 기본 모드의 채팅 인터페이스" data-og-width="2048" width="2048" data-og-height="2350" height="2350" data-path="images/chat/compact/off.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/compact/off.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=9395c8d1f324033631508dc9cdfd6f3e 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/compact/off.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=5d8025ef65ad2fc9fe8c30e5c4fcda32 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/compact/off.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=28050b27b683af948bc1ed939f31786c 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/compact/off.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=dc443705188da9d3368acefd917cc890 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/compact/off.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=be6603e2cedb7e88e7c20d797b18599c 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/compact/off.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=3afe563c9cd4576623adce5dcaaccddf 2500w" />
</Frame>

<div id="compact-mode">
  ### 컴팩트 모드
</div>

<Frame>
  <img src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/compact/on.png?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=e9f068889026827422b2a9d943b55ded" alt="아이콘이 숨겨지고 요소가 접힌 컴팩트 모드의 채팅 인터페이스" data-og-width="2048" width="2048" data-og-height="2350" height="2350" data-path="images/chat/compact/on.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/compact/on.png?w=280&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=44e86a79eb893b4de6c57c65487bbe9a 280w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/compact/on.png?w=560&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=539b71c72ed2fb3508e3aec0624429c1 560w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/compact/on.png?w=840&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=2c0da715a5daf93e94dbf2a5eefbb7eb 840w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/compact/on.png?w=1100&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=b5bddca39109779c9d91bb6bc8bb42e9 1100w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/compact/on.png?w=1650&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=8bb334bb055e49d4d51cd137d2396db0 1650w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/compact/on.png?w=2500&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=70730d151a24440eeb6dc31e18189c7d 2500w" />
</Frame>

<div id="enabling-compact-mode">
  ## 컴팩트 모드 활성화
</div>

컴팩트 모드를 켜려면:

1. Cursor Settings 열기
2. **Chat** 설정으로 이동
3. **Compact Mode** 토글 켜기

인터페이스가 바로 슬림한 보기로 전환돼서 대화에 더 집중할 수 있는 공간이 늘어나.



# Duplicate
Source: https://docs.cursor.com/ko/agent/chat/duplicate

대화의 어느 지점에서든 분기 만들기

현재 대화를 잃지 않고 대안을 탐색하려면 채팅을 복제/포크해.

<Frame>
  <video src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/duplicate-chat.mp4?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=29fdb23214ba3e2c5b94ccefc01f7615" autoPlay loop muted playsInline controls data-path="images/chat/duplicate-chat.mp4" />
</Frame>

<div id="how-to-duplicate">
  ## 복제하는 방법
</div>

1. 분기할 지점 찾기
2. 메시지의 점 세 개 클릭하기
3. "Duplicate Chat" 선택하기

<div id="what-happens">
  ## 어떻게 동작해
</div>

* 그 시점까지의 컨텍스트가 유지돼
* 기존 대화는 바뀌지 않아
* 두 채팅은 각각 별도의 기록을 유지해



# 내보내기
Source: https://docs.cursor.com/ko/agent/chat/export

채팅을 마크다운 형식으로 내보내기

Agent 채팅을 공유하거나 문서화할 수 있도록 마크다운 파일로 내보내자.

<Frame>
  <video src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/export-chat.mp4?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=c6aa9d23a6a80ffae5864cd494907961" autoPlay loop muted playsInline controls data-path="images/chat/export-chat.mp4" />
</Frame>

<div id="whats-exported">
  ## 내보내는 항목
</div>

* 모든 메시지와 응답
* 구문 하이라이팅이 적용된 코드 블록
* 파일 참조와 콘텍스트
* 시간순 대화 흐름

<div id="how-to-export">
  ## 내보내는 방법
</div>

1. 내보낼 채팅으로 이동
2. 컨텍스트 메뉴 → "Export Chat" 클릭
3. 파일을 로컬에 저장

<Warning>
  내보낸 파일에서 민감한 데이터 확인: API 키, 내부 URL, 독점 코드,
  개인 정보
</Warning>



# 히스토리
Source: https://docs.cursor.com/ko/agent/chat/history

채팅 대화 보기 및 관리

export const Kbd = ({children, tooltip, os}) => {
  const keysInput = typeof children === 'string' && children.trim() !== '' ? children : null;
  if (!keysInput) {
    return null;
  }
  const isModifier = key => {
    const modifiers = ['⌘', '⇧', '⌥', '⌃', '⏎', '⌫', '⌦', '⎋', '⇥', '⌁', '←', '→', '↑', '↓', 'Ctrl', 'Shift', 'Alt', 'Cmd', 'Opt', 'Return', 'Backspace', 'Delete', 'Escape', 'Tab', 'Space', 'Enter', 'Esc', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down'];
    return modifiers.includes(key.trim());
  };
  const capitalizeFirstLetter = string => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  const isMac = os ? os.toLowerCase() === 'mac' || os.toLowerCase() === 'macos' : typeof navigator !== 'undefined' && (navigator.platform.toUpperCase().indexOf('MAC') >= 0 || navigator.userAgent.toUpperCase().indexOf('MAC') >= 0);
  const convertToSymbols = shortcut => {
    if (isMac) {
      return shortcut.replace(/⌘|Cmd|CMD/gi, '⌘').replace(/⌥|Opt|OPT/gi, '⌥').replace(/⌃|Ctrl/gi, '⌃').replace(/⇧|Shift/gi, '⇧').replace(/⏎|Return/gi, '⏎').replace(/⌫|Backspace/gi, '⌫').replace(/⌦|Delete/gi, '⌦').replace(/␛|Escape/gi, '␛').replace(/⇥|Tab/gi, '⇥').replace(/⌁|Space/gi, '⌁').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, '←').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, '→').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, '↑').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, '↓');
    } else {
      const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Ctrl').replace(/⌥|Opt|OPT/gi, 'Alt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Enter').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Esc').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
      const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
      return keyList.join('+');
    }
  };
  const convertToReadableText = shortcut => {
    const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Cmd').replace(/⌥|Opt|OPT/gi, 'Opt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Return').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Escape').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
    const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
    return keyList.map(key => {
      const trimmedKey = key.trim();
      return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
    }).join('+');
  };
  const displayShortcut = convertToSymbols(keysInput);
  const tooltipText = isMac ? tooltip ? `${convertToReadableText(keysInput)}: ${tooltip}` : convertToReadableText(keysInput) : tooltip || null;
  const processedKeys = isMac ? displayShortcut.split(/[\+\s]+/).filter(key => key.trim()).map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('') : displayShortcut.split('+').map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('+');
  return tooltipText ? <Tooltip tip={tooltipText}>
      <kbd>
        {processedKeys}
      </kbd>
    </Tooltip> : <kbd>
      {processedKeys}
    </kbd>;
};

히스토리 패널에서 이전 Agent 대화를 확인할 수 있어.

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=d9ec96fad0c8c2fb132bbf5ce8ea35f7" alt="Chat History" data-og-width="2048" width="2048" data-og-height="1317" height="1317" data-path="images/chat/chat-history.jpeg" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=a3ad71e9891c3c9642f4288953a78e97 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=76139a177ebfeb0c55add7fb955f9000 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1af22180859c017542777ab36b434b7a 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=751e7fa0888e5790f841432ef7521337 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=86b447c18601a9d44af8866d0042719e 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=88c84a8fb1b764ad3070e3211f539408 2500w" />
</Frame>

<div id="opening-history">
  ## 기록 열기
</div>

* Agent 사이드패인에서 기록 아이콘 클릭
* <Kbd tooltip="Open chat history">Opt Cmd '</Kbd> 누르기

<div id="managing-chats">
  ## 채팅 관리
</div>

* **제목 편집**: 클릭해 이름 바꾸기
* **삭제**: 필요 없는 채팅 삭제
* **열기**: 클릭해 전체 대화 보기

채팅 기록은 네 기기 로컬의 SQLite 데이터베이스에 저장돼.

<Note>
  채팅을 보관하려면 [마크다운으로 내보내](/ko/agent/chats/export) 둬.
</Note>

<div id="background-agents">
  ## 백그라운드 에이전트
</div>

백그라운드 에이전트 채팅은 일반 기록에 남지 않고 원격 데이터베이스에 저장돼. <Kbd tooltip="Open background agent control panel">Cmd E</Kbd>로 열어서 확인해.

<div id="referencing-past-chats">
  ## 이전 채팅 참조하기
</div>

현재 채팅에 이전 대화의 맥락을 포함하려면 [@Past Chats](/ko/context/@-symbols/@-past-chats)를 사용해.



# 요약
Source: https://docs.cursor.com/ko/agent/chat/summarization

채팅에서 장기 대화를 위한 컨텍스트 관리

<div id="message-summarization">
  ## 메시지 요약
</div>

대화가 길어질수록 Cursor가 자동으로 요약하고 컨텍스트를 관리해서 채팅을 효율적으로 유지해 줘. 컨텍스트 메뉴를 쓰는 법과 파일이 모델 컨텍스트 윈도우에 맞게 어떻게 축약·압축되는지 알아봐.

<div id="using-the-summarize-command">
  ### /summarize 명령어 사용하기
</div>

채팅에서 `/summarize` 명령어로 요약을 직접 실행할 수 있어. 이 명령어는 대화가 너무 길어질 때 컨텍스트를 관리해, 중요한 정보를 놓치지 않고 효율적으로 작업을 이어갈 수 있게 도와줘.

<Info>
  Cursor에서 컨텍스트가 어떻게 작동하는지 더 자세히 알아보려면 [컨텍스트로
  작업하기](/ko/guides/working-with-context) 가이드를 확인해봐.
</Info>

<div id="how-summarization-works">
  ### 요약 방식
</div>

대화가 길어지면 모델의 컨텍스트 윈도우 제한을 넘게 돼:

<Frame>
  <div className="font-mono text-xs w-full bg-neutral-100 p-4 rounded-lg">
    <div className="relative">
      <div className="bg-white px-3 py-2 mb-2 rounded border border-dashed border-neutral-400 w-full">
        <div className="text-xs text-neutral-700 font-medium">User</div>
      </div>

      <div className="bg-white px-3 py-2 mb-2 rounded border border-dashed border-neutral-400 w-full">
        <div className="text-xs text-neutral-700 font-medium">Cursor</div>
      </div>

      <div className="bg-white px-3 py-2 mb-2 rounded border border-dashed border-neutral-400 w-full">
        <div className="text-xs text-neutral-700 font-medium">User</div>
      </div>

      <div className="relative my-4">
        <div className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center text-xs text-black bg-neutral-100 px-2">컨텍스트 윈도우 제한</div>

        <div className="w-full h-px bg-black" />
      </div>

      <div className="bg-white px-3 py-2 mb-2 rounded border border-neutral-400 w-full">
        <div className="text-xs text-neutral-700 font-medium">Cursor</div>
      </div>

      <div className="bg-white px-3 py-2 mb-2 rounded border border-neutral-400 w-full">
        <div className="text-xs text-neutral-700 font-medium">User</div>
      </div>

      <div className="bg-white px-3 py-2 mb-2 rounded border border-neutral-400 w-full">
        <div className="text-xs text-neutral-700 font-medium">Cursor</div>
      </div>
    </div>
  </div>
</Frame>

이걸 해결하려고 Cursor는 오래된 메시지를 요약해서 새 대화를 위한 공간을 만들어.

<Frame>
  <div className="font-mono text-xs w-full bg-neutral-100 p-4 rounded-lg">
    <div className="relative">
      <div className="relative my-4">
        <div className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center text-xs text-black bg-neutral-100 px-2">
          컨텍스트 윈도우 제한
        </div>

        <div className="w-full h-px bg-black" />
      </div>

      <div className="bg-neutral-100 px-3 py-2 mb-2 rounded border border-dashed border-neutral-400 w-full">
        <div className="text-xs text-neutral-700 font-medium">
          요약된 메시지
        </div>
      </div>

      <div className="bg-white px-3 py-2 mb-2 rounded border border-neutral-400 w-full">
        <div className="text-xs text-neutral-700 font-medium">Cursor</div>
      </div>

      <div className="bg-white px-3 py-2 mb-2 rounded border border-neutral-400 w-full">
        <div className="text-xs text-neutral-700 font-medium">User</div>
      </div>

      <div className="bg-white px-3 py-2 mb-2 rounded border border-neutral-400 w-full">
        <div className="text-xs text-neutral-700 font-medium">Cursor</div>
      </div>
    </div>
  </div>
</Frame>

## 파일 & 폴더 축약

채팅 요약이 긴 대화를 다루는 동안, Cursor는 큰 파일과 폴더를 관리할 때 **스마트 축약**이라는 다른 전략을 써. 대화에 파일을 포함하면, Cursor가 파일 크기와 사용할 수 있는 컨텍스트 공간을 바탕으로 가장 알맞은 표시 방식을 결정해.

파일/폴더가 가질 수 있는 상태는 다음과 같아:

<div id="condensed">
  ### 축약
</div>

파일이나 폴더가 컨텍스트 윈도우에 다 담기엔 너무 클 때, Cursor가 자동으로 축약해. 축약은 모델에 함수 시그니처, 클래스, 메서드 같은 핵심 구조를 보여줘. 이 축약 뷰에서 모델은 필요하면 특정 파일을 선택해 펼칠 수 있어. 이 방식은 사용 가능한 컨텍스트 윈도우를 가장 효율적으로 써.

<Frame>
  <img src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/condensed.png?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=0c3a07b6fef6402945138f7ee38b44c1" alt="컨텍스트 메뉴" data-og-width="1226" width="1226" data-og-height="793" height="793" data-path="images/context/context-management/condensed.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/condensed.png?w=280&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=4cc08626f9cfce1d186cdd6aa96c7d09 280w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/condensed.png?w=560&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=fa49ce9605bdb0186c98712f4c0a32cc 560w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/condensed.png?w=840&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=84874b2f40bff0a2cd54796865469914 840w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/condensed.png?w=1100&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=050290a85c154e92f9298883afcdf892 1100w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/condensed.png?w=1650&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=f953aa28f11926b2d6fdf734cf928402 1650w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/condensed.png?w=2500&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=50aa9973ccf2027814860f3d97a2b031 2500w" />
</Frame>

<div id="significantly-condensed">
  ### 대폭 축약됨
</div>

파일 이름에 "대폭 축약됨" 라벨이 붙어 있으면, 그 파일은 축약해도 전체를 담기엔 너무 커. 모델에는 파일 이름만 보여줘.

<div id="not-included">
  ### 포함되지 않음
</div>

파일이나 폴더 옆에 경고 아이콘이 보이면, 그 항목은 축약해도 컨텍스트 창에 넣기엔 너무 큰 거야. 이렇게 표시해 주면 코드베이스 중에서 모델이 접근할 수 있는 부분을 쉽게 알 수 있어.

<Frame>
  <img src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/not-included.png?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=06df9854c74c257d1ceb7d18b1864ceb" alt="Context menu" data-og-width="1090" width="1090" data-og-height="346" height="346" data-path="images/context/context-management/not-included.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/not-included.png?w=280&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=072e75878f27a151f1310007d0e5e534 280w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/not-included.png?w=560&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=c6f3f71351ddf8e367096651b455bf9d 560w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/not-included.png?w=840&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=c407f7870412007549f8eb2871f9ca12 840w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/not-included.png?w=1100&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=b0d17023b5734c8d7584c56f5419bd1a 1100w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/not-included.png?w=1650&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=f1bedff398cee6c957fe62877f7d2012 1650w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/context-management/not-included.png?w=2500&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=8b00fbaff658c384f69bfddf3f3a4cfe 2500w" />
</Frame>



# 탭
Source: https://docs.cursor.com/ko/agent/chat/tabs

여러 Agent 대화를 동시에 진행

export const Kbd = ({children, tooltip, os}) => {
  const keysInput = typeof children === 'string' && children.trim() !== '' ? children : null;
  if (!keysInput) {
    return null;
  }
  const isModifier = key => {
    const modifiers = ['⌘', '⇧', '⌥', '⌃', '⏎', '⌫', '⌦', '⎋', '⇥', '⌁', '←', '→', '↑', '↓', 'Ctrl', 'Shift', 'Alt', 'Cmd', 'Opt', 'Return', 'Backspace', 'Delete', 'Escape', 'Tab', 'Space', 'Enter', 'Esc', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down'];
    return modifiers.includes(key.trim());
  };
  const capitalizeFirstLetter = string => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  const isMac = os ? os.toLowerCase() === 'mac' || os.toLowerCase() === 'macos' : typeof navigator !== 'undefined' && (navigator.platform.toUpperCase().indexOf('MAC') >= 0 || navigator.userAgent.toUpperCase().indexOf('MAC') >= 0);
  const convertToSymbols = shortcut => {
    if (isMac) {
      return shortcut.replace(/⌘|Cmd|CMD/gi, '⌘').replace(/⌥|Opt|OPT/gi, '⌥').replace(/⌃|Ctrl/gi, '⌃').replace(/⇧|Shift/gi, '⇧').replace(/⏎|Return/gi, '⏎').replace(/⌫|Backspace/gi, '⌫').replace(/⌦|Delete/gi, '⌦').replace(/␛|Escape/gi, '␛').replace(/⇥|Tab/gi, '⇥').replace(/⌁|Space/gi, '⌁').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, '←').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, '→').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, '↑').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, '↓');
    } else {
      const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Ctrl').replace(/⌥|Opt|OPT/gi, 'Alt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Enter').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Esc').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
      const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
      return keyList.join('+');
    }
  };
  const convertToReadableText = shortcut => {
    const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Cmd').replace(/⌥|Opt|OPT/gi, 'Opt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Return').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Escape').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
    const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
    return keyList.map(key => {
      const trimmedKey = key.trim();
      return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
    }).join('+');
  };
  const displayShortcut = convertToSymbols(keysInput);
  const tooltipText = isMac ? tooltip ? `${convertToReadableText(keysInput)}: ${tooltip}` : convertToReadableText(keysInput) : tooltip || null;
  const processedKeys = isMac ? displayShortcut.split(/[\+\s]+/).filter(key => key.trim()).map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('') : displayShortcut.split('+').map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('+');
  return tooltipText ? <Tooltip tip={tooltipText}>
      <kbd>
        {processedKeys}
      </kbd>
    </Tooltip> : <kbd>
      {processedKeys}
    </kbd>;
};

<Frame>
  <video src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-tabs.mp4?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=57fd5305279dc0a3139055b353ce4b7a" autoPlay loop muted playsInline controls data-path="images/chat/chat-tabs.mp4" />
</Frame>

<div id="overview">
  ## 개요
</div>

새 탭을 만들려면 <Kbd>Cmd+T</Kbd>를 눌러. 각 탭은 대화 기록, 컨텍스트, 모델 선택을 각각 따로 유지해.

<Tip>
  병렬 작업엔 [Background Agents](/ko/background-agents)를 써봐
</Tip>

<div id="managing-tabs">
  ## 탭 관리
</div>

* <Kbd>Cmd+T</Kbd>로 새 탭 만들기. 각 탭은 새 대화로 시작하고 자체 컨텍스트를 유지해.

* 탭 헤더를 클릭하거나 <Kbd>Ctrl+Tab</Kbd>으로 순환해서 탭을 전환해.

* 탭 제목은 첫 메시지 이후 자동 생성돼. 탭 헤더를 오른쪽 클릭해서 이름을 바꿀 수도 있어.

<Tip>
  탭당 작업은 하나로, 초기 설명은 명확하게, 끝난 탭은 닫아서 워크스페이스를 깔끔하게 유지해.
</Tip>

<div id="conflicts">
  ### 충돌
</div>

Cursor는 여러 탭이 같은 파일을 동시에 편집하지 못하게 막아. 충돌을 해결하라는 안내가 뜰 거야.

<div id="reference-other-chats">
  ## 다른 채팅 참고하기
</div>

[@Past Chats](/ko/context/@-symbols/@-past-chats)를 사용해서 다른 탭이나 이전 세션의 내용을 컨텍스트로 포함해.



# 모드
Source: https://docs.cursor.com/ko/agent/modes

작업에 맞는 모드를 선택하세요 — 자동 코딩부터 집중 편집까지

export const Kbd = ({children, tooltip, os}) => {
  const keysInput = typeof children === 'string' && children.trim() !== '' ? children : null;
  if (!keysInput) {
    return null;
  }
  const isModifier = key => {
    const modifiers = ['⌘', '⇧', '⌥', '⌃', '⏎', '⌫', '⌦', '⎋', '⇥', '⌁', '←', '→', '↑', '↓', 'Ctrl', 'Shift', 'Alt', 'Cmd', 'Opt', 'Return', 'Backspace', 'Delete', 'Escape', 'Tab', 'Space', 'Enter', 'Esc', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down'];
    return modifiers.includes(key.trim());
  };
  const capitalizeFirstLetter = string => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  const isMac = os ? os.toLowerCase() === 'mac' || os.toLowerCase() === 'macos' : typeof navigator !== 'undefined' && (navigator.platform.toUpperCase().indexOf('MAC') >= 0 || navigator.userAgent.toUpperCase().indexOf('MAC') >= 0);
  const convertToSymbols = shortcut => {
    if (isMac) {
      return shortcut.replace(/⌘|Cmd|CMD/gi, '⌘').replace(/⌥|Opt|OPT/gi, '⌥').replace(/⌃|Ctrl/gi, '⌃').replace(/⇧|Shift/gi, '⇧').replace(/⏎|Return/gi, '⏎').replace(/⌫|Backspace/gi, '⌫').replace(/⌦|Delete/gi, '⌦').replace(/␛|Escape/gi, '␛').replace(/⇥|Tab/gi, '⇥').replace(/⌁|Space/gi, '⌁').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, '←').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, '→').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, '↑').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, '↓');
    } else {
      const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Ctrl').replace(/⌥|Opt|OPT/gi, 'Alt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Enter').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Esc').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
      const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
      return keyList.join('+');
    }
  };
  const convertToReadableText = shortcut => {
    const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Cmd').replace(/⌥|Opt|OPT/gi, 'Opt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Return').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Escape').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
    const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
    return keyList.map(key => {
      const trimmedKey = key.trim();
      return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
    }).join('+');
  };
  const displayShortcut = convertToSymbols(keysInput);
  const tooltipText = isMac ? tooltip ? `${convertToReadableText(keysInput)}: ${tooltip}` : convertToReadableText(keysInput) : tooltip || null;
  const processedKeys = isMac ? displayShortcut.split(/[\+\s]+/).filter(key => key.trim()).map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('') : displayShortcut.split('+').map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('+');
  return tooltipText ? <Tooltip tip={tooltipText}>
      <kbd>
        {processedKeys}
      </kbd>
    </Tooltip> : <kbd>
      {processedKeys}
    </kbd>;
};

Agent는 특정 작업에 최적화된 다양한 모드를 제공해. 각 모드는 니 워크플로에 맞춰 서로 다른 기능과 도구가 활성화돼.

<div className="full-width-table">
  | Mode                  | For          | Capabilities       | Tools       |
  | :-------------------- | :----------- | :----------------- | :---------- |
  | **[Agent](#agent)**   | 복잡한 기능, 리팩터링 | 자율 탐색, 다중 파일 편집    | 모든 도구 사용 가능 |
  | **[Ask](#ask)**       | 학습, 계획, 질문   | 읽기 전용 탐색, 자동 변경 없음 | 검색 도구만      |
  | **[Custom](#custom)** | 특화된 워크플로     | 사용자 정의 가능 기능       | 구성 가능       |
</div>

<div id="agent">
  ## Agent
</div>

복잡한 코딩 작업을 위한 기본 모드야. Agent는 코드베이스를 자동으로 탐색하고, 여러 파일을 수정하고, 명령을 실행하고, 오류를 고쳐서 네 요청을 완수해.

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=9cd06dd9f59e019b3d76aa0fd9f934ba" data-og-width="3600" width="3600" data-og-height="2025" height="2025" data-path="images/chat/agent.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=d979435c61e2112ebcb784f16a49327f 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1a88e2085ffe80f02daea9a523887282 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=de98a8bf766c3f35a6187e87190e30f9 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=8648638c4240b718e0512a6ec2274171 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=45b9898d65f5b425d276eaa44d4e1940 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=30fef2b190d453ee0166e554a4005bd1 2500w" />
</Frame>

<div id="ask">
  ## Ask
</div>

학습과 탐색을 위한 읽기 전용 모드야. Ask는 코드베이스를 검색해서 아무 변경도 하지 않고 답을 제공해—코드를 수정하기 전에 이해하기에 딱 좋아.

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/ask.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=15e531cb84f0a18228723870fd84fa4f" data-og-width="3600" width="3600" data-og-height="2025" height="2025" data-path="images/chat/ask.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/ask.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=592ac5a681910a075ae88dec89bee25d 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/ask.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=74b98cce3b5bb83c79d0566cd3c65c34 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/ask.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=c4d80f50e20e7ca28db5a3ee71718979 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/ask.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=a4a6e017fd64149cf68d997114bbf6b6 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/ask.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=7354479ecd644b86ddbcb9fe1131f100 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/ask.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=274125e614eadd17522e0dacfcc6a38e 2500w" />
</Frame>

<div id="custom">
  ## 커스텀
</div>

특정 도구 조합과 지침으로 너만의 모드를 만들어. 워크플로우에 맞게 기능을 믹스매치해 써.

<Note>
  커스텀 모드는 베타야. `Cursor Settings` → `Chat` → `Custom
      Modes`에서 켜줘
</Note>

<div id="examples">
  ### 예시
</div>

<AccordionGroup>
  <Accordion title="Learn">
    **Tools:** All Search\
    **Instructions:** 개념을 충분히 풀어서 설명하고, 애매한 부분은 확인 질문을 해줘
  </Accordion>

  {" "}

  <Accordion title="Refactor">
    **Tools:** Edit & Reapply **Instructions:** 새로운 기능을 추가하지 않고 코드 구조만 개선해
  </Accordion>

  {" "}

  <Accordion title="Plan">
    **Tools:** Codebase, Read file, Terminal **Instructions:** `plan.md`에 상세한 구현 계획을 작성해
  </Accordion>

  <Accordion title="Debug">
    **Tools:** All Search, Terminal, Edit & Reapply\
    **Instructions:** 수정안을 제시하기 전에 문제를 충분히 조사해
  </Accordion>
</AccordionGroup>

<div id="switching-modes">
  ## 모드 전환
</div>

* Agent에서 모드 선택 드롭다운 사용하기
* 빠르게 전환하려면 <Kbd>Cmd+.</Kbd> 누르기
* [설정](#settings)에서 키보드 단축키 지정하기

<div id="settings">
  ## 설정
</div>

모든 모드는 공통 설정 옵션을 공유해:

<div className="full-width-table">
  | 설정      | 설명            |
  | :------ | :------------ |
  | 모델      | 사용할 AI 모델 선택  |
  | 키보드 단축키 | 모드 전환용 단축키 설정 |
</div>

모드별 설정:

<div className="full-width-table">
  | 모드         | 설정               | 설명                                    |
  | :--------- | :--------------- | :------------------------------------ |
  | **Agent**  | 자동 실행 및 자동 오류 수정 | 명령을 자동 실행하고 오류를 자동 수정                 |
  | **Ask**    | 코드베이스 검색         | 관련 파일을 자동으로 찾기                        |
  | **Custom** | 도구 선택 & 안내       | [tools](/ko/agent/tools)와 커스텀 프롬프트 구성 |
</div>



# 개요
Source: https://docs.cursor.com/ko/agent/overview

자율형 코딩 작업, 터미널 명령, 코드 편집을 위한 어시스턴트

export const Kbd = ({children, tooltip, os}) => {
  const keysInput = typeof children === 'string' && children.trim() !== '' ? children : null;
  if (!keysInput) {
    return null;
  }
  const isModifier = key => {
    const modifiers = ['⌘', '⇧', '⌥', '⌃', '⏎', '⌫', '⌦', '⎋', '⇥', '⌁', '←', '→', '↑', '↓', 'Ctrl', 'Shift', 'Alt', 'Cmd', 'Opt', 'Return', 'Backspace', 'Delete', 'Escape', 'Tab', 'Space', 'Enter', 'Esc', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down'];
    return modifiers.includes(key.trim());
  };
  const capitalizeFirstLetter = string => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  const isMac = os ? os.toLowerCase() === 'mac' || os.toLowerCase() === 'macos' : typeof navigator !== 'undefined' && (navigator.platform.toUpperCase().indexOf('MAC') >= 0 || navigator.userAgent.toUpperCase().indexOf('MAC') >= 0);
  const convertToSymbols = shortcut => {
    if (isMac) {
      return shortcut.replace(/⌘|Cmd|CMD/gi, '⌘').replace(/⌥|Opt|OPT/gi, '⌥').replace(/⌃|Ctrl/gi, '⌃').replace(/⇧|Shift/gi, '⇧').replace(/⏎|Return/gi, '⏎').replace(/⌫|Backspace/gi, '⌫').replace(/⌦|Delete/gi, '⌦').replace(/␛|Escape/gi, '␛').replace(/⇥|Tab/gi, '⇥').replace(/⌁|Space/gi, '⌁').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, '←').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, '→').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, '↑').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, '↓');
    } else {
      const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Ctrl').replace(/⌥|Opt|OPT/gi, 'Alt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Enter').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Esc').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
      const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
      return keyList.join('+');
    }
  };
  const convertToReadableText = shortcut => {
    const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Cmd').replace(/⌥|Opt|OPT/gi, 'Opt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Return').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Escape').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
    const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
    return keyList.map(key => {
      const trimmedKey = key.trim();
      return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
    }).join('+');
  };
  const displayShortcut = convertToSymbols(keysInput);
  const tooltipText = isMac ? tooltip ? `${convertToReadableText(keysInput)}: ${tooltip}` : convertToReadableText(keysInput) : tooltip || null;
  const processedKeys = isMac ? displayShortcut.split(/[\+\s]+/).filter(key => key.trim()).map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('') : displayShortcut.split('+').map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('+');
  return tooltipText ? <Tooltip tip={tooltipText}>
      <kbd>
        {processedKeys}
      </kbd>
    </Tooltip> : <kbd>
      {processedKeys}
    </kbd>;
};

Agent는 Cursor의 어시스턴트로, 복잡한 코딩 작업을 스스로 처리하고 터미널 명령을 실행하며 코드를 편집할 수 있어. 사이드패인에서 <Kbd>Cmd+I</Kbd>로 열어봐.

<Frame caption="사이드패인에서의 Agent">
  <video src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/overview.mp4?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=b17d6a1225b4992ea19978b6a6c259e1" autoPlay loop muted playsInline data-path="images/chat/overview.mp4" />
</Frame>

<div className="mt-24 flex flex-col gap-12">
  <Columns className="gap-4">
    <div>
      <h2 className="text-lg font-medium mb-2">
        <a href="/ko/agent/modes" className="hover:text-primary transition-colors">
          Modes
        </a>
      </h2>

      <p className="text-sm">
        Agent, Ask 중에서 선택하거나 커스텀 모드를 만들어. 각 모드는
        네 워크플로에 맞는 서로 다른 기능과 도구를 제공해.
      </p>
    </div>

    <Frame>
      <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=9cd06dd9f59e019b3d76aa0fd9f934ba" alt="Agent modes" data-og-width="3600" width="3600" data-og-height="2025" height="2025" data-path="images/chat/agent.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=d979435c61e2112ebcb784f16a49327f 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1a88e2085ffe80f02daea9a523887282 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=de98a8bf766c3f35a6187e87190e30f9 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=8648638c4240b718e0512a6ec2274171 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=45b9898d65f5b425d276eaa44d4e1940 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/agent.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=30fef2b190d453ee0166e554a4005bd1 2500w" />
    </Frame>
  </Columns>

  <Columns className="gap-4">
    <div>
      <h3 className="text-lg font-medium mb-2">
        <a href="/ko/agent/tools" className="hover:text-primary transition-colors">
          도구
        </a>
      </h3>

      <p className="text-sm">
        Agent는 도구로 검색하고, 편집하고, 명령을 실행해. 시맨틱 코드베이스
        검색부터 터미널 실행까지, 이런 도구들이 자율적으로 작업을
        끝내도록 도와줘.
      </p>
    </div>

    <div>
      <Frame>
        <img src="https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=3135722076a5aa636d27dbedec665bae" alt="Agent 도구" data-og-width="1624" width="1624" data-og-height="1012" height="1012" data-path="images/agent/auto-run.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=280&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=9f2e2bed8f634201adc51ccb2bd96cd2 280w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=560&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=51704cac2f270a04856fffbeaccf9700 560w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=840&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=01a5034975497a8dff4f41dca0d19f2e 840w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=1100&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=5f19026a0c6e5fb28c935ce795edb706 1100w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=1650&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=a108fc86f8ee7c0db6e5b7ab80ede738 1650w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=2500&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=9ce5f45879c29049640bb5a1494db11e 2500w" />
      </Frame>
    </div>
  </Columns>

  <Columns className="gap-4">
    <div>
      <h3 className="text-lg font-medium mb-2">
        <a href="/ko/agent/apply" className="hover:text-primary transition-colors">
          변경 적용
        </a>
      </h3>

      <p className="text-sm">
        AI가 제안한 코드 블록을 코드베이스에 바로 통합해. Apply는
        정밀도를 유지하면서 대규모 변경도 효율적으로 처리해.
      </p>
    </div>

    <div>
      <Frame>
        <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=634492fa2f63b4f6eada08b2a1ded47e" alt="변경 적용" data-og-width="1032" width="1032" data-og-height="410" height="410" data-path="images/chat/apply.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=7dbc88cfe20429c73e627a289b17c964 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=721e2d51bdb16dbb817e19d96d93c9d9 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=8faea188ca903e58d347ddfec2c9bf6e 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=f3bc38701cab63602b54374dfaa9e024 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=fddad51f5b12c32493e2370ed326712d 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/apply.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1584d431007b33a595905e23b5e1b453 2500w" />
      </Frame>
    </div>
  </Columns>

  <Columns className="gap-4">
    <div>
      <h3 className="text-lg font-medium mb-2">
        <a href="/ko/agent/review" className="hover:text-primary transition-colors">
          변경사항 검토
        </a>
      </h3>

      <p className="text-sm">
        적용하기 전에 변경 내용을 확인해. 검토 인터페이스는 추가와 삭제를 색상으로 구분된 라인으로 보여줘서 수정 사항을 더 정밀하게 컨트롤할 수 있어.
      </p>
    </div>

    <div>
      <Frame>
        <video src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/review/review-bar.mp4?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=5dca0fe7aba3c79e6760cb264821a617" autoPlay loop muted playsInline controls data-path="images/chat/review/review-bar.mp4" />
      </Frame>
    </div>
  </Columns>

  <Columns className="gap-4">
    <div>
      <h3 className="text-lg font-medium mb-2">
        <a href="/ko/agent/chats/tabs" className="hover:text-primary transition-colors">
          채팅 탭
        </a>
      </h3>

      <p className="text-sm">
        <Kbd>Cmd+T</Kbd>로 여러 대화를 동시에 진행해. 각 탭은 자체 컨텍스트, 히스토리, 그리고 선택한 모델을 따로 유지해.
      </p>
    </div>

    <div>
      <Frame>
        <video src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-tabs.mp4?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=57fd5305279dc0a3139055b353ce4b7a" autoPlay loop muted playsInline controls data-path="images/chat/chat-tabs.mp4" />
      </Frame>
    </div>
  </Columns>

  <Columns className="gap-4">
    <div>
      <h3 className="text-lg font-medium mb-2">
        <a href="/ko/agent/chats/checkpoints" className="hover:text-primary transition-colors">
          체크포인트
        </a>
      </h3>

      <p className="text-sm">
        자동 스냅샷이 에이전트의 변경사항을 추적해. 예상대로 동작하지 않거나 다른 방법을 시도해보고 싶다면 이전 상태로 복원할 수 있어.
      </p>
    </div>

    <div>
      <Frame>
        <video src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/restore-checkpoint.mp4?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=7cededf7892f15a6342a81953ea0aa38" autoPlay loop muted playsInline controls data-path="images/chat/restore-checkpoint.mp4" />
      </Frame>
    </div>
  </Columns>

  <Columns className="gap-4">
    <div>
      <h3 className="text-lg font-medium mb-2">
        <a href="/ko/agent/terminal" className="hover:text-primary transition-colors">
          터미널 연동
        </a>
      </h3>

      <p className="text-sm">
        Agent가 터미널 명령을 실행하고 출력을 모니터링하며 여러 단계의
        프로세스를 처리해. 신뢰하는 워크플로에는 자동 실행을 설정하고,
        안전을 위해 확인을 요구하도록 할 수도 있어.
      </p>
    </div>

    <div>
      <Frame>
        <img src="https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=3135722076a5aa636d27dbedec665bae" alt="Terminal integration" data-og-width="1624" width="1624" data-og-height="1012" height="1012" data-path="images/agent/auto-run.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=280&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=9f2e2bed8f634201adc51ccb2bd96cd2 280w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=560&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=51704cac2f270a04856fffbeaccf9700 560w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=840&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=01a5034975497a8dff4f41dca0d19f2e 840w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=1100&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=5f19026a0c6e5fb28c935ce795edb706 1100w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=1650&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=a108fc86f8ee7c0db6e5b7ab80ede738 1650w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=2500&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=9ce5f45879c29049640bb5a1494db11e 2500w" />
      </Frame>
    </div>
  </Columns>

  <Columns className="gap-4">
    <div>
      <h3 className="text-lg font-medium mb-2">
        <a href="/ko/agent/chats/history" className="hover:text-primary transition-colors">
          채팅 기록
        </a>
      </h3>

      <p className="text-sm">
        <Kbd>Opt Cmd '</Kbd>로 이전 대화를 열람해. 지난
        논의를 검토하고, 코딩 세션을 추적하고, 이전
        채팅의 컨텍스트를 참고할 수 있어.
      </p>
    </div>

    <div>
      <Frame>
        <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=d9ec96fad0c8c2fb132bbf5ce8ea35f7" alt="Chat history" data-og-width="2048" width="2048" data-og-height="1317" height="1317" data-path="images/chat/chat-history.jpeg" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=a3ad71e9891c3c9642f4288953a78e97 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=76139a177ebfeb0c55add7fb955f9000 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=1af22180859c017542777ab36b434b7a 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=751e7fa0888e5790f841432ef7521337 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=86b447c18601a9d44af8866d0042719e 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/chat/chat-history.jpeg?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=88c84a8fb1b764ad3070e3211f539408 2500w" />
      </Frame>
    </div>
  </Columns>

  <Columns className="gap-4">
    <div>
      <h3 className="text-lg font-medium mb-2">
        <a href="/ko/agent/chats/export" className="hover:text-primary transition-colors">
          채팅 내보내기
        </a>
      </h3>

      <p className="text-sm">
        대화를 Markdown 형식으로 내보내. 팀원들과 해결책을 공유하고, 결정 사항을 문서화하거나, 코딩
        세션에서 지식 베이스를 만들어.
      </p>
    </div>

    <div>
      <Frame>
        <video src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/export-chat.mp4?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=c6aa9d23a6a80ffae5864cd494907961" autoPlay loop muted playsInline controls data-path="images/chat/export-chat.mp4" />
      </Frame>
    </div>
  </Columns>

  <Columns className="gap-4">
    <div>
      <h3 className="text-lg font-medium mb-2">
        <a href="/ko/context/rules" className="hover:text-primary transition-colors">
          규칙
        </a>
      </h3>

      <p className="text-sm">
        Agent의 동작을 정의하는 맞춤형 지침을 설정해. 규칙은 코딩
        표준을 유지하고, 일관된 패턴을 적용하며, Agent가 네
        프로젝트를 도와주는 방식을 개인화해줘.
      </p>
    </div>

    <div>
      <Frame>
        <img src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/rules/rules-applied.png?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=e637bab83cfd5dcc8a3b15ed6fd9fc15" alt="Agent rules" data-og-width="1198" width="1198" data-og-height="674" height="674" data-path="images/context/rules/rules-applied.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/rules/rules-applied.png?w=280&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=78e3c392987c6f95a02fc106753c5f98 280w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/rules/rules-applied.png?w=560&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=9d3a8b76ba99ada5ca302cba9fb63810 560w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/rules/rules-applied.png?w=840&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=f5ab7fb374a1a4c5fe2f50e2e50d233a 840w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/rules/rules-applied.png?w=1100&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=5d25394a29c1da4172a3e673ee384c07 1100w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/rules/rules-applied.png?w=1650&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=0fc125bd3c2a93551674252c0523d3ec 1650w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/context/rules/rules-applied.png?w=2500&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=c576ea053ee18c30d2781c6bdd394a70 2500w" />
      </Frame>
    </div>
  </Columns>
</div>



# 계획
Source: https://docs.cursor.com/ko/agent/planning

Agent가 할 일과 큐를 통해 복잡한 작업을 계획하고 관리하는 방법

export const Kbd = ({children, tooltip, os}) => {
  const keysInput = typeof children === 'string' && children.trim() !== '' ? children : null;
  if (!keysInput) {
    return null;
  }
  const isModifier = key => {
    const modifiers = ['⌘', '⇧', '⌥', '⌃', '⏎', '⌫', '⌦', '⎋', '⇥', '⌁', '←', '→', '↑', '↓', 'Ctrl', 'Shift', 'Alt', 'Cmd', 'Opt', 'Return', 'Backspace', 'Delete', 'Escape', 'Tab', 'Space', 'Enter', 'Esc', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down'];
    return modifiers.includes(key.trim());
  };
  const capitalizeFirstLetter = string => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  const isMac = os ? os.toLowerCase() === 'mac' || os.toLowerCase() === 'macos' : typeof navigator !== 'undefined' && (navigator.platform.toUpperCase().indexOf('MAC') >= 0 || navigator.userAgent.toUpperCase().indexOf('MAC') >= 0);
  const convertToSymbols = shortcut => {
    if (isMac) {
      return shortcut.replace(/⌘|Cmd|CMD/gi, '⌘').replace(/⌥|Opt|OPT/gi, '⌥').replace(/⌃|Ctrl/gi, '⌃').replace(/⇧|Shift/gi, '⇧').replace(/⏎|Return/gi, '⏎').replace(/⌫|Backspace/gi, '⌫').replace(/⌦|Delete/gi, '⌦').replace(/␛|Escape/gi, '␛').replace(/⇥|Tab/gi, '⇥').replace(/⌁|Space/gi, '⌁').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, '←').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, '→').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, '↑').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, '↓');
    } else {
      const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Ctrl').replace(/⌥|Opt|OPT/gi, 'Alt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Enter').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Esc').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
      const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
      return keyList.join('+');
    }
  };
  const convertToReadableText = shortcut => {
    const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Cmd').replace(/⌥|Opt|OPT/gi, 'Opt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Return').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Escape').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
    const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
    return keyList.map(key => {
      const trimmedKey = key.trim();
      return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
    }).join('+');
  };
  const displayShortcut = convertToSymbols(keysInput);
  const tooltipText = isMac ? tooltip ? `${convertToReadableText(keysInput)}: ${tooltip}` : convertToReadableText(keysInput) : tooltip || null;
  const processedKeys = isMac ? displayShortcut.split(/[\+\s]+/).filter(key => key.trim()).map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('') : displayShortcut.split('+').map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('+');
  return tooltipText ? <Tooltip tip={tooltipText}>
      <kbd>
        {processedKeys}
      </kbd>
    </Tooltip> : <kbd>
      {processedKeys}
    </kbd>;
};

Agent는 구조화된 할 일 목록과 메시지 큐잉으로 선제적으로 계획하고 복잡한 작업을 관리해서, 장기적인 작업을 더 쉽게 파악하고 추적할 수 있게 해줘.

<div id="agent-to-dos">
  ## Agent 할 일
</div>

Agent는 긴 작업을 의존 관계가 있는 관리 가능한 단계로 쪼개서, 진행에 따라 업데이트되는 구조화된 계획을 만들어.

<video autoPlay loop muted playsInline controls>
  <source src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/agent/planning/agent-todo.mp4?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=b0285913832a3ef123fe149516ee37ea" type="video/mp4" data-path="images/agent/planning/agent-todo.mp4" />
</video>

<div id="how-it-works">
  ### 동작 방식
</div>

* Agent가 복잡한 작업의 할 일 목록을 자동으로 생성해
* 각 항목은 다른 작업에 대한 의존 관계를 가질 수 있어
* 작업 진행에 따라 목록이 실시간으로 업데이트돼
* 완료된 작업은 자동으로 표시돼

<div id="visibility">
  ### 표시
</div>

* 할 일은 채팅 인터페이스에 표시돼
* [Slack 연동](/ko/slack)을 설정했다면, 거기서도 할 일을 볼 수 있어
* 언제든 전체 작업 분해를 확인할 수 있어

<Tip>
  더 나은 계획을 위해 최종 목표를 명확히 설명해 줘. 전체 범위를 이해하면 Agent가 더
  정확한 작업 분해를 만들어 줄 거야.
</Tip>

<Note>현재 자동 모드에서는 계획과 할 일이 지원되지 않아.</Note>

<div id="queued-messages">
  ## 대기열 메시지
</div>

Agent가 현재 작업을 진행하는 동안 후속 메시지를 대기열에 넣어 둬. 네 지침은 줄서 있다가 준비되면 자동으로 실행돼.

<video autoPlay loop muted playsInline controls>
  <source src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/agent/planning/agent-queue.mp4?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=4cdd6a7d1e12c67e520bc3ba67a42e0d" type="video/mp4" data-path="images/agent/planning/agent-queue.mp4" />
</video>

<div id="using-the-queue">
  ### 대기열 사용하기
</div>

1. Agent가 작업 중일 때, 다음 지시를 입력해
2. <Kbd>Ctrl+Enter</Kbd>를 눌러 대기열에 추가해
3. 메시지는 활성 작업 아래에 순서대로 표시돼
4. 화살표를 눌러 대기열 메시지 순서를 바꿔
5. Agent는 작업을 마친 뒤 순서대로 처리해

<div id="override-the-queue">
  ### 대기열 건너뛰기
</div>

기본 메시징 대신 메시지를 대기열에 넣으려면 <Kbd>Ctrl+Enter</Kbd>를 써. 대기열에 넣지 않고 바로 보내려면 <Kbd>Cmd+Enter</Kbd>를 써. 이렇게 하면 대기열을 우회해 즉시 실행되도록 네 메시지를 강제로 밀어 넣어.

<div id="default-messaging">
  ## 기본 메시징
</div>

메시지는 기본적으로 가능한 한 빨리 전송돼. 보통 Agent가 도구 호출을 끝내자마자 바로 표시돼서, 가장 빠릿한 반응성을 경험할 수 있어.

<div id="how-default-messaging-works">
  ### 기본 메시징의 동작 방식
</div>

* 네 메시지는 채팅에서 가장 최근 사용자 메시지에 이어서 붙어
* 메시지는 보통 도구 결과에 연결되고, 준비되는 즉시 전송돼
* 이렇게 하면 Agent의 현재 작업을 끊지 않고 더 자연스러운 대화 흐름이 만들어져
* 기본적으로 Agent가 작업 중일 때 Enter를 누르면 이렇게 동작해



# Diffs & Review
Source: https://docs.cursor.com/ko/agent/review

AI 에이전트가 생성한 코드 변경 사항 검토 및 관리

Agent가 코드 변경을 만들면, 추가와 삭제를 색상으로 구분한 라인으로 보여주는 리뷰 인터페이스에서 표시돼. 이를 통해 어떤 변경을 코드베이스에 적용할지 검토하고 제어할 수 있어.

리뷰 인터페이스는 익숙한 diff 형식으로 코드 변경을 보여줘:

<div id="diffs">
  ## Diffs
</div>

<div className="full-width-table">
  | Type              | Meaning       | Example                                                                                               |
  | :---------------- | :------------ | :---------------------------------------------------------------------------------------------------- |
  | **Added lines**   | 새 코드 추가       | <code className="bg-green-100 text-green-800 px-2 py-1 rounded">+ const newVariable = 'hello';</code> |
  | **Deleted lines** | 코드 삭제         | <code className="bg-red-100 text-red-800 px-2 py-1 rounded">- const oldVariable = 'goodbye';</code>   |
  | **Context lines** | 변경되지 않은 주변 코드 | <code className="bg-gray-100 text-gray-600 px-2 py-1 rounded"> function example() {}</code>           |
</div>

<div id="review">
  ## 검토
</div>

생성이 끝나면, 진행하기 전에 모든 변경 사항을 확인하라는 프롬프트가 떠. 이걸로 뭐가 바뀌는지 한눈에 볼 수 있어.

<Frame>
  <img src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/review/input-review.png?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=10633167c76c24c1e69748ef93dc3888" alt="입력 검토 인터페이스" data-og-width="2095" width="2095" data-og-height="1178" height="1178" data-path="images/chat/review/input-review.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/review/input-review.png?w=280&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=f462337898ca48f71cd2b570b140d30d 280w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/review/input-review.png?w=560&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=07c91dfc92110cce444da8bbf3d0b3b5 560w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/review/input-review.png?w=840&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=492522862dabae6243fa8d33f6fd77f2 840w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/review/input-review.png?w=1100&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=c897e19ce7f508bad4e24fcf8efb2512 1100w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/review/input-review.png?w=1650&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=3956c2d2c5c9156181b19e262e301b5b 1650w, https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/review/input-review.png?w=2500&fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=907f90b1db432128964a7f4e59523bb6 2500w" />
</Frame>

<div id="file-by-file">
  ### 파일별
</div>

화면 하단에 떠 있는 검토 바가 나타나서 이렇게 할 수 있어:

* 현재 파일의 변경 사항을 **수락**하거나 **거부**하기
* 보류 중인 변경이 있는 **다음 파일**로 이동하기
  <Frame>
    <video src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/chat/review/review-bar.mp4?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=5dca0fe7aba3c79e6760cb264821a617" autoPlay loop muted playsInline controls data-path="images/chat/review/review-bar.mp4">
      브라우저가 video 태그를 지원하지 않아.
    </video>
  </Frame>

<div id="selective-acceptance">
  ### 선택적 수락
</div>

더 세밀하게 제어하려면:

* 대부분의 변경을 수락하려면: 원치 않는 줄을 거부한 뒤 **모두 수락** 클릭
* 대부분의 변경을 거부하려면: 원하는 줄을 수락한 뒤 **모두 거부** 클릭

<div id="review-changes">
  ## 변경 사항 리뷰
</div>

에이전트 응답 맨 끝에서 **변경 사항 리뷰** 버튼을 눌러 변경 내용의 전체 diff를 확인해.

<Frame>
  <video src="https://www.cursor.com/changelog/049/review-ui.mp4" autoPlay loop muted playsInline controls />
</Frame>



# Terminal
Source: https://docs.cursor.com/ko/agent/terminal

에이전트 작업의 일부로 터미널 명령을 자동 실행

에이전트는 Cursor의 기본 터미널에서 기록을 유지한 채 명령을 실행해. 건너뛰기를 클릭하면 <kbd>Ctrl+C</kbd>를 보내서 명령을 중단해.

<div id="troubleshooting">
  ## 문제 해결
</div>

<Info>
  일부 셸 테마(예: Powerlevel9k/Powerlevel10k)는 인라인 터미널 출력에
  영향을 줄 수 있어. 명령 결과가 잘리거나 형식이 깨져 보이면, Agent가 실행될 때
  테마를 끄거나 더 단순한 프롬프트로 바꿔줘.
</Info>

<div id="disable-heavy-prompts-for-agent-sessions">
  ### Agent 세션에서는 무거운 프롬프트 끄기
</div>

셸 설정에서 `CURSOR_AGENT` 환경 변수를 사용해 Agent가 실행 중일 때를 감지하고,
화려한 프롬프트/테마 초기화는 건너뛰어.

```zsh  theme={null}

# ~/.zshrc — Cursor Agent가 실행될 때 Powerlevel10k 비활성화
if [[ -n "$CURSOR_AGENT" ]]; then
  # 호환성을 높이기 위해 테마 초기화를 건너뜀
else
  [[ -r ~/.p10k.zsh ]] && source ~/.p10k.zsh
fi
```

```bash  theme={null}

# ~/.bashrc — Agent 세션에서는 단순한 프롬프트로 대체
if [[ -n "$CURSOR_AGENT" ]]; then
  PS1='\u@\h \W \$ '
fi
```



# Tools
Source: https://docs.cursor.com/ko/agent/tools

코드를 검색·편집·실행하기 위해 에이전트가 사용할 수 있는 도구

[Agent](/ko/agent/overview) 내 각 모드에서 사용할 수 있는 모든 도구 목록이야. 직접 [custom modes](/ko/agent/modes#custom)를 만들 때 도구를 켜거나 끌 수 있어.

<Note>
  작업 중 Agent가 호출할 수 있는 도구 횟수에는 제한이 없어. 요청을 완료할 때까지 필요한 만큼 계속 사용할 거야.
</Note>

<div id="search">
  ## 검색
</div>

코드베이스와 웹에서 관련 정보를 찾는 검색 도구들.

<AccordionGroup>
  <Accordion title="Read File" icon="file-lines">
    파일을 최대 250줄까지 읽어 (최대 모드에선 750줄).
  </Accordion>

  <Accordion title="List Directory" icon="folder-open">
    파일 내용을 읽지 않고 디렉터리 구조만 확인해.
  </Accordion>

  <Accordion title="Codebase" icon="database">
    [인덱싱된
    코드베이스](/ko/context/codebase-indexing)에서 시맨틱 검색을 수행해.
  </Accordion>

  <Accordion title="Grep" icon="magnifying-glass">
    파일에서 정확한 키워드나 패턴을 찾아.
  </Accordion>

  <Accordion title="Search Files" icon="file-magnifying-glass">
    퍼지 매칭으로 파일 이름을 찾아.
  </Accordion>

  <Accordion title="Web" icon="globe">
    검색 쿼리를 만들고 웹 검색을 실행해.
  </Accordion>

  <Accordion title="Fetch Rules" icon="gavel">
    유형과 설명에 맞는 특정 [규칙](/ko/context/rules)을 가져와.
  </Accordion>
</AccordionGroup>

<div id="edit">
  ## 편집
</div>

파일과 코드베이스에 특정 수정을 가하는 도구.

<AccordionGroup>
  <Accordion title="수정 & 재적용" icon="pencil">
    파일에 대한 수정 사항을 제안하고 [apply](/ko/agent/apply)로 자동 적용해.
  </Accordion>

  <Accordion title="파일 삭제" icon="trash">
    파일을 자동으로 삭제해 (설정에서 끌 수 있어).
  </Accordion>
</AccordionGroup>

<div id="run">
  ## 실행
</div>

Chat이 터미널과 상호작용할 수 있어.

<AccordionGroup>
  <Accordion title="Terminal" icon="terminal">
    터미널 명령을 실행하고 출력을 모니터링해.
  </Accordion>
</AccordionGroup>

<Note>기본적으로 Cursor는 사용 가능한 첫 번째 터미널 프로필을 써.</Note>

선호하는 터미널 프로필을 설정하려면:

1. Command Palette 열기 (`Cmd/Ctrl+Shift+P`)
2. "Terminal: Select Default Profile" 검색
3. 원하는 프로필 선택

<div id="mcp">
  ## MCP
</div>

Chat은 설정된 MCP 서버를 통해 데이터베이스나 서드파티 API 같은 외부 서비스와 상호작용할 수 있어.

<AccordionGroup>
  <Accordion title="MCP 서버 토글" icon="server">
    사용 가능한 MCP 서버를 토글해. 자동 실행 설정을 따를 거야.
  </Accordion>
</AccordionGroup>

[Model Context Protocol](/ko/context/model-context-protocol)에 대해 더 알아보고, [MCP 디렉터리](/ko/tools)에서 사용 가능한 서버를 확인해봐.

<div id="advanced-options">
  ## 고급 옵션
</div>

<AccordionGroup>
  <Accordion title="Auto-apply Edits" icon="check">
    수동 확인 없이 편집을 자동 적용해.
  </Accordion>

  <Accordion title="Auto-run" icon="play">
    터미널 명령을 자동 실행하고 편집도 자동으로 수락해. 테스트 스위트 실행이나 변경 사항 검증에 유용해.

    <Frame>
      <img src="https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=3135722076a5aa636d27dbedec665bae" data-og-width="1624" width="1624" data-og-height="1012" height="1012" data-path="images/agent/auto-run.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=280&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=9f2e2bed8f634201adc51ccb2bd96cd2 280w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=560&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=51704cac2f270a04856fffbeaccf9700 560w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=840&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=01a5034975497a8dff4f41dca0d19f2e 840w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=1100&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=5f19026a0c6e5fb28c935ce795edb706 1100w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=1650&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=a108fc86f8ee7c0db6e5b7ab80ede738 1650w, https://mintcdn.com/cursor/M0haYabx4OPGBjqe/images/agent/auto-run.png?w=2500&fit=max&auto=format&n=M0haYabx4OPGBjqe&q=85&s=9ce5f45879c29049640bb5a1494db11e 2500w" />
    </Frame>
  </Accordion>

  <Accordion title="Guardrails" icon="shield">
    자동 실행을 허용할 도구를 지정하는 allowlist를 설정해. allowlist는 허용된 작업을 명시적으로 정의해서 보안을 강화해.
  </Accordion>

  <Accordion title="Auto-fix Errors" icon="wrench">
    Agent가 발견한 린터 오류와 경고를 자동으로 고쳐.
  </Accordion>
</AccordionGroup>



# 백그라운드 에이전트
Source: https://docs.cursor.com/ko/background-agent

Cursor의 비동기 원격 에이전트

export const Kbd = ({children, tooltip, os}) => {
  const keysInput = typeof children === 'string' && children.trim() !== '' ? children : null;
  if (!keysInput) {
    return null;
  }
  const isModifier = key => {
    const modifiers = ['⌘', '⇧', '⌥', '⌃', '⏎', '⌫', '⌦', '⎋', '⇥', '⌁', '←', '→', '↑', '↓', 'Ctrl', 'Shift', 'Alt', 'Cmd', 'Opt', 'Return', 'Backspace', 'Delete', 'Escape', 'Tab', 'Space', 'Enter', 'Esc', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down'];
    return modifiers.includes(key.trim());
  };
  const capitalizeFirstLetter = string => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  const isMac = os ? os.toLowerCase() === 'mac' || os.toLowerCase() === 'macos' : typeof navigator !== 'undefined' && (navigator.platform.toUpperCase().indexOf('MAC') >= 0 || navigator.userAgent.toUpperCase().indexOf('MAC') >= 0);
  const convertToSymbols = shortcut => {
    if (isMac) {
      return shortcut.replace(/⌘|Cmd|CMD/gi, '⌘').replace(/⌥|Opt|OPT/gi, '⌥').replace(/⌃|Ctrl/gi, '⌃').replace(/⇧|Shift/gi, '⇧').replace(/⏎|Return/gi, '⏎').replace(/⌫|Backspace/gi, '⌫').replace(/⌦|Delete/gi, '⌦').replace(/␛|Escape/gi, '␛').replace(/⇥|Tab/gi, '⇥').replace(/⌁|Space/gi, '⌁').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, '←').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, '→').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, '↑').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, '↓');
    } else {
      const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Ctrl').replace(/⌥|Opt|OPT/gi, 'Alt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Enter').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Esc').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
      const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
      return keyList.join('+');
    }
  };
  const convertToReadableText = shortcut => {
    const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Cmd').replace(/⌥|Opt|OPT/gi, 'Opt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Return').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Escape').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
    const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
    return keyList.map(key => {
      const trimmedKey = key.trim();
      return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
    }).join('+');
  };
  const displayShortcut = convertToSymbols(keysInput);
  const tooltipText = isMac ? tooltip ? `${convertToReadableText(keysInput)}: ${tooltip}` : convertToReadableText(keysInput) : tooltip || null;
  const processedKeys = isMac ? displayShortcut.split(/[\+\s]+/).filter(key => key.trim()).map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('') : displayShortcut.split('+').map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('+');
  return tooltipText ? <Tooltip tip={tooltipText}>
      <kbd>
        {processedKeys}
      </kbd>
    </Tooltip> : <kbd>
      {processedKeys}
    </kbd>;
};

백그라운드 에이전트를 사용해 원격 환경에서 코드를 편집하고 실행하는 비동기 에이전트를 생성해. 상태를 확인하고, 후속 지시를 보내거나, 언제든 직접 넘겨받아 진행할 수 있어.

<div id="how-to-use">
  ## 사용 방법
</div>

백그라운드 에이전트는 두 가지 방식으로 사용할 수 있어:

1. **Background Agent Sidebar**: Cursor 기본 사이드바의 백그라운드 에이전트 탭에서 계정에 연결된 모든 백그라운드 에이전트를 확인하고, 기존 에이전트를 검색하거나 새로 시작할 수 있어.
2. **Background Agent Mode**: UI에서 백그라운드 에이전트 모드를 켜려면 <Kbd tooltip="Trigger background agent mode">Cmd E</Kbd>를 눌러.

프롬프트를 제출한 뒤 목록에서 에이전트를 선택해 상태를 확인하고 머신에 진입해.

<Note>
  <p className="!mb-0">
    백그라운드 에이전트는 수일간의 데이터 보관이 필요해.
  </p>
</Note>

<div id="setup">
  ## 설정
</div>

백그라운드 에이전트는 기본적으로 격리된 Ubuntu 기반 머신에서 실행돼. 에이전트는 인터넷에 액세스할 수 있고 패키지를 설치할 수 있어.

<div id="github-connection">
  #### GitHub 연결
</div>

백그라운드 에이전트가 GitHub에서 레포를 클론하고 별도 브랜치에서 작업한 다음, 손쉬운 넘겨주기를 위해 네 레포로 푸시해.

레포(종속 레포나 서브모듈 포함)에 읽기/쓰기 권한을 부여해 줘. 다른 제공자(GitLab, Bitbucket 등)는 앞으로 지원할 예정이야.

<div id="ip-allow-list-configuration">
  ##### IP 허용 목록 구성
</div>

조직에서 GitHub의 IP 허용 목록 기능을 사용한다면, 백그라운드 에이전트가 접근할 수 있도록 설정해야 해. 연락처 정보와 IP 주소를 포함한 전체 설정 방법은 [GitHub 통합 문서](/ko/integrations/github#ip-allow-list-configuration)를 참고해.

<div id="base-environment-setup">
  #### 기본 환경 설정
</div>

더 고급 시나리오에선 직접 환경을 세팅해. 원격 머신에 연결된 IDE 인스턴스를 준비하고, 로컬 머신을 설정해서 툴과 패키지를 설치한 다음 스냅샷을 찍어. 런타임 설정은 이렇게 구성해:

* Install 커맨드는 에이전트가 시작되기 전에 실행돼서 런타임 의존성을 설치해. 예를 들어 `npm install`이나 `bazel build`를 돌릴 수도 있어.
* Terminals는 에이전트가 작업하는 동안 백그라운드 프로세스를 실행해 — 웹 서버를 띄우거나 protobuf 파일을 컴파일하는 식으로.

가장 고급 케이스에선 머신 설정에 Dockerfile을 써. 이 Dockerfile로 시스템 레벨 의존성을 구성할 수 있어: 특정 컴파일러 버전이나 디버거를 설치하거나, 베이스 OS 이미지를 바꾸는 것까지. 프로젝트 전체를 `COPY`하진 마 — 워크스페이스는 우리가 관리하고 올바른 커밋을 체크아웃해. 의존성 설치는 여전히 install 스크립트에서 처리해.

개발 환경에 필요한 시크릿을 입력해 — 시크릿은 우리 데이터베이스에 저장 시 암호화(At-rest, KMS 사용)돼 있고, 백그라운드 에이전트 환경에 제공돼.

머신 설정은 `.cursor/environment.json`에 들어 있어. 이 파일은 레포에 커밋해도 되고(권장), 비공개로 보관해도 돼. 설정 플로우가 `environment.json` 생성 과정을 안내해 줄 거야.

<div id="maintenance-commands">
  #### 유지 관리 명령
</div>

새 머신을 설정할 때는 기본 환경에서 시작한 다음 `environment.json`의 `install` 명령을 실행해. 이 명령은 브랜치를 전환할 때 개발자가 실행하는 것과 같아—새 의존성을 설치하는 거지.

대부분은 `install` 명령이 `npm install` 또는 `bazel build`야.

빠른 머신 시작을 위해 `install` 명령 실행 후 디스크 상태를 캐시해. 여러 번 실행해도 되도록 설계해. 지속되는 건 `install` 명령으로 인한 디스크 상태뿐이야—여기서 시작한 프로세스는 에이전트가 시작될 때 살아 있지 않아.

<div id="startup-commands">
  #### 시작 명령어
</div>

`install`를 실행한 뒤 머신이 올라오면 `start` 명령어를 실행하고, 이어서 모든 `terminals`를 시작해. 그러면 에이전트가 돌 때 살아 있어야 하는 프로세스들이 올라가.

`start` 명령어는 보통 생략해도 돼. 네 dev 환경이 Docker에 의존한다면 써 — `start` 명령어에 `sudo service docker start`를 넣어.

`terminals`는 앱 코드용이야. 이 터미널들은 너와 에이전트가 함께 쓸 수 있는 `tmux` 세션에서 실행돼. 예를 들어, 많은 웹사이트 레포는 `npm run watch`를 터미널로 넣어.

<div id="the-environmentjson-spec">
  #### `environment.json` 스펙
</div>

`environment.json` 파일은 다음처럼 생길 수 있어:

```json  theme={null}
{
  "snapshot": "설정에서 가져옴",
  "install": "npm install",
  "terminals": [
    {
      "name": "Next.js 실행",
      "command": "npm run dev"
    }
  ]
}
```

공식적으로, 스펙은 [여기에서 정의돼 있어](https://www.cursor.com/schemas/environment.schema.json).

<div id="models">
  ## 모델
</div>

백그라운드 에이전트에선 [Max Mode](/ko/context/max-mode) 호환 모델만 쓸 수 있어.

<div id="pricing">
  ## 가격
</div>

[Background Agent 가격](/ko/account/pricing#background-agent)에 대해 더 알아보기.

<div id="security">
  ## 보안
</div>

Background Agents는 개인정보 보호 모드에서 사용할 수 있어. 우린 네 코드로 학습하지 않고, 에이전트를 실행하는 데 필요한 코드만 보관해. [개인정보 보호 모드 자세히 보기](https://www.cursor.com/privacy-overview).

알아두면 좋은 점:

1. 수정하려는 리포에 우리 GitHub 앱의 읽기/쓰기 권한을 부여해줘. 이걸로 리포를 클론하고 변경할 수 있어.
2. 네 코드는 격리된 VM으로 구성된 우리 AWS 인프라에서 실행되고, 에이전트가 동작하는 동안 VM 디스크에 저장돼.
3. 에이전트는 인터넷에 접근할 수 있어.
4. 에이전트는 모든 터미널 명령을 자동 실행해서 테스트를 반복할 수 있게 해줘. 이건 모든 명령에 사용자 승인이 필요한 포그라운드 에이전트와 달라. 자동 실행은 데이터 유출 위험을 초래할 수 있어: 공격자가 프롬프트 인젝션 공격으로 에이전트를 속여 악성 웹사이트에 코드를 업로드하게 만들 수 있어. [배경 에이전트에 대한 프롬프트 인젝션 위험에 관한 OpenAI의 설명](https://platform.openai.com/docs/codex/agent-network#risks-of-agent-internet-access)을 참고해.
5. 개인정보 보호 모드를 비활성화하면, 제품 개선을 위해 프롬프트와 개발 환경 정보를 수집해.
6. 백그라운드 에이전트를 시작할 때 개인정보 보호 모드를 비활성화한 뒤, 에이전트 실행 중에 활성화하더라도 완료될 때까지 비활성화 상태로 계속 진행돼.

<div id="dashboard-settings">
  ## 대시보드 설정
</div>

워크스페이스 관리자는 대시보드의 Background Agents 탭에서 추가 설정을 변경할 수 있어.

<div id="defaults-settings">
  ### 기본값 설정
</div>

* **기본 모델** – 실행에서 모델을 지정하지 않았을 때 사용되는 모델. Max Mode를 지원하는 아무 모델이나 골라.
* **기본 리포지토리** – 비워두면 에이전트가 리포 선택을 요청해. 여기에서 리포를 지정하면 그 단계를 건너뛸 수 있어.
* **기본 브랜치(Base branch)** – 에이전트가 풀 리퀘스트를 만들 때 포크하는 기준 브랜치. 리포지토리의 기본 브랜치를 쓰려면 비워 둬.

<div id="security-settings">
  ### 보안 설정
</div>

모든 보안 옵션은 관리자 권한이 필요해.

* **사용자 제한** – *없음*(모든 멤버가 백그라운드 에이전트를 시작할 수 있음) 또는 *허용 목록* 중에서 선택해. *허용 목록*으로 설정하면 어떤 팀원이 에이전트를 만들 수 있는지 정확히 지정할 수 있어.
* **팀 팔로업** – 켜면 워크스페이스의 누구나 다른 사람이 시작한 에이전트에 팔로업 메시지를 추가할 수 있어. 끄면 팔로업은 에이전트 소유자와 관리자에게만 허용돼.
* **에이전트 요약 표시** – Cursor가 에이전트의 파일 diff 이미지와 코드 스니펫을 표시할지 제어해. 사이드바에 파일 경로나 코드를 노출하고 싶지 않다면 꺼둬.
* **외부 채널에 에이전트 요약 표시** – 위 토글을 Slack이나 연결된 외부 채널에도 적용해.

변경 사항은 즉시 저장되고 새 에이전트에 바로 적용돼.



# 후속 지시 추가
Source: https://docs.cursor.com/ko/background-agent/api/add-followup

en/background-agent/api/openapi.yaml post /v0/agents/{id}/followup
실행 중인 백그라운드 에이전트에 추가 지시를 보내.




# Agent Conversation
Source: https://docs.cursor.com/ko/background-agent/api/agent-conversation

en/background-agent/api/openapi.yaml get /v0/agents/{id}/conversation
백그라운드 에이전트의 대화 내역을 가져와.

백그라운드 에이전트가 삭제됐으면 대화 내역에 접근할 수 없어.



# 에이전트 상태
Source: https://docs.cursor.com/ko/background-agent/api/agent-status

en/background-agent/api/openapi.yaml get /v0/agents/{id}
특정 백그라운드 에이전트의 현재 상태와 결과를 조회해.




# API 키 정보
Source: https://docs.cursor.com/ko/background-agent/api/api-key-info

en/background-agent/api/openapi.yaml get /v0/me
인증에 쓰인 API 키의 메타데이터를 가져와.




# 에이전트 삭제
Source: https://docs.cursor.com/ko/background-agent/api/delete-agent

en/background-agent/api/openapi.yaml delete /v0/agents/{id}
백그라운드 에이전트와 연결된 리소스를 영구적으로 삭제해.




# 에이전트 시작하기
Source: https://docs.cursor.com/ko/background-agent/api/launch-an-agent

en/background-agent/api/openapi.yaml post /v0/agents
레포지토리에서 작업할 새 백그라운드 에이전트를 시작해.




# 에이전트 목록
Source: https://docs.cursor.com/ko/background-agent/api/list-agents

en/background-agent/api/openapi.yaml get /v0/agents
인증된 사용자의 모든 백그라운드 에이전트를 페이지로 나눠 조회한다.




# 모델 목록
Source: https://docs.cursor.com/ko/background-agent/api/list-models

en/background-agent/api/openapi.yaml get /v0/models
백그라운드 에이전트에 추천되는 모델 목록을 조회해.

생성 시 백그라운드 에이전트의 모델을 지정하려면, 이 엔드포인트로 추천 모델 목록을 확인하면 돼.

이때 "Auto" 옵션도 함께 두는 걸 추천해. 그 옵션을 선택하면 생성 엔드포인트에 모델 이름을 넘기지 않고, 우리가 가장 적합한 모델을 자동으로 선택해 줄게.



# GitHub 저장소 목록
Source: https://docs.cursor.com/ko/background-agent/api/list-repositories

en/background-agent/api/openapi.yaml get /v0/repositories
인증된 사용자가 접근할 수 있는 GitHub 저장소 목록을 가져온다.

<Warning>
  **이 엔드포인트에는 매우 엄격한 rate limit가 걸려 있어.**

  요청을 **1/사용자/분**, **30/사용자/시간**으로 제한해.

  많은 저장소에 접근 권한이 있는 사용자는 응답까지 수십 초가 걸릴 수 있어.

  이 정보가 없을 때도 문제없이 처리하도록 해.
</Warning>



# 개요
Source: https://docs.cursor.com/ko/background-agent/api/overview

저장소에서 동작하는 백그라운드 에이전트를 프로그래밍적으로 생성하고 관리하기

<div id="background-agents-api">
  # Background Agents API
</div>

<Badge variant="beta">Beta</Badge>

Background Agents API를 쓰면 리포지토리에서 자율적으로 일하는 AI 코딩 에이전트를 코드로 만들어서 관리할 수 있어.
이 API로 사용자 피드백에 자동 응답하고, 버그를 고치고, 문서를 업데이트하고, 그 밖의 작업들도 잔뜩 자동화할 수 있어!

<Info>
  Background Agents API는 현재 베타야. 너의 피드백을 정말 듣고 싶어!
</Info>

<div id="key-features">
  ## 핵심 기능
</div>

* **자율 코드 생성** - 프롬프트를 이해하고 코드베이스를 수정할 수 있는 에이전트를 만들어
* **리포지토리 통합** - GitHub 리포지토리와 바로 작업해
* 후속 프롬프트 - 실행 중인 에이전트에 추가 지시를 더해
* **사용량 기반 과금** - 사용한 토큰만큼만 결제해
* **확장성** - API 키당 최대 256개의 활성 에이전트를 지원해

<div id="quick-start">
  ## 빠른 시작
</div>

<div id="1-get-your-api-key">
  ### 1. API 키 받기
</div>

API 키를 만들려면 [Cursor Dashboard → Integrations](https://cursor.com/dashboard?tab=integrations)로 이동해.

<div id="2-start-using-the-api">
  ### 2. API 사용 시작하기
</div>

모든 API 엔드포인트는 다음 기준 경로를 따르지:

```
https://api.cursor.com
```

자세한 엔드포인트 목록은 [API 레퍼런스](/ko/background-agent/api/launch-an-agent)를 참고해.

<div id="authentication">
  ## 인증
</div>

모든 API 요청은 Bearer 토큰으로 인증해야 해:

```
Authorization: Bearer YOUR_API_KEY
```

API 키는 [Cursor Dashboard](https://cursor.com/dashboard?tab=integrations)에서 만들 수 있어. 키는 계정에 범위가 묶여 있고, 에이전트를 생성하고 관리할 수 있는 권한을 부여해(플랜 한도와 리포지토리 접근 권한을 따름).

<div id="pricing">
  ## 요금
</div>

API는 현재 베타 단계고, Background Agents와 같은 요금이 적용돼. 서비스 규모가 커지면 요금이 바뀔 수 있어. [Background Agent 요금](/ko/account/pricing#background-agent)을 확인해.

<div id="next-steps">
  ## 다음 단계
</div>

* 환경, 권한, 워크플로를 이해하려면 메인 [Background Agents 개요](/ko/background-agent)를 읽어봐.
* [웹 & 모바일](/ko/background-agent/web-and-mobile)에서 Background Agents를 직접 써봐.
* [Discord #background-agent](https://discord.gg/jfgpZtYpmb)에서 얘기 나누거나 [background-agent-feedback@cursor.com](mailto:background-agent-feedback@cursor.com)로 메일 보내줘.



# Webhooks
Source: https://docs.cursor.com/ko/background-agent/api/webhooks

백그라운드 에이전트 상태 변경 실시간 알림

<div id="webhooks">
  # Webhooks
</div>

웹훅 URL로 에이전트를 만들면 Cursor가 상태 변경을 알리려고 HTTP POST 요청을 보냄. 현재는 에이전트가 `ERROR` 또는 `FINISHED` 상태에 도달했을 때 발생하는 `statusChange` 이벤트만 지원함.

<div id="webhook-verification">
  ## Webhook 검증
</div>

Webhook 요청이 진짜로 Cursor에서 온 건지 확인하려면, 각 요청에 포함된 서명을 검증해:

<div id="headers">
  ### Headers
</div>

각 webhook 요청에는 다음 헤더가 포함돼:

* **`X-Webhook-Signature`** – `sha256=<hex_digest>` 형식의 HMAC-SHA256 서명
* **`X-Webhook-ID`** – 이 전달에 대한 고유 식별자(로그에 유용)
* **`X-Webhook-Event`** – 이벤트 타입(현재는 `statusChange`만)
* **`User-Agent`** – 항상 `Cursor-Agent-Webhook/1.0`으로 설정

<div id="signature-verification">
  ### 서명 검증
</div>

Webhook 서명을 검증하려면, 예상 서명을 계산해서 받은 서명과 비교해:

```javascript  theme={null}
const crypto = require('crypto');

function verifyWebhook(secret, rawBody, signature) {
  const expectedSignature = 'sha256=' + 
    crypto.createHmac('sha256', secret)
          .update(rawBody)
          .digest('hex');
  
  return signature === expectedSignature;
}
```

```python  theme={null}
import hmac
import hashlib

def verify_webhook(secret, raw_body, signature):
    expected_signature = 'sha256=' + hmac.new(
        secret.encode(),
        raw_body,
        hashlib.sha256
    ).hexdigest()
    
    return signature == expected_signature
```

서명을 계산할 땐 항상 파싱 전에 원본 요청 본문(raw body)을 써.

<div id="payload-format">
  ## 페이로드 형식
</div>

웹훅 페이로드는 아래 구조의 JSON으로 전송돼:

```json  theme={null}
{
  "event": "statusChange",
  "timestamp": "2024-01-15T10:30:00Z",
  "id": "bc_abc123",
  "status": "FINISHED",
  "source": {
    "repository": "https://github.com/your-org/your-repo",
    "ref": "main"
  },
  "target": {
    "url": "https://cursor.com/agents?id=bc_abc123",
    "branchName": "cursor/add-readme-1234",
    "prUrl": "https://github.com/your-org/your-repo/pull/1234"
  },
  "summary": "설치 안내가 포함된 README.md 추가"
}
```

일부 필드는 선택적이어서, 사용 가능한 경우에만 포함돼.

<div id="best-practices">
  ## 모범 사례
</div>

* **서명 검증** – 요청이 Cursor에서 왔는지 확인하려면 항상 웹훅 서명을 검증해
* **재시도 처리** – 엔드포인트가 오류 상태 코드를 반환하면 웹훅이 재시도될 수 있어
* **빠른 응답** – 가능한 한 빨리 2xx 상태 코드를 반환해
* **HTTPS 사용** – 프로덕션 환경의 웹훅 엔드포인트에는 항상 HTTPS URL을 사용해
* **원본 페이로드 저장** – 디버깅과 추후 검증을 위해 웹훅 원본 페이로드를 저장해



# 웹 & 모바일
Source: https://docs.cursor.com/ko/background-agent/web-and-mobile

어떤 기기에서든 코딩 에이전트를 실행하고 데스크톱으로 매끄럽게 이어가기

<div id="overview">
  ## 개요
</div>

Cursor의 웹용 Agent는 강력한 코딩 어시스턴트를 모든 기기로 가져와. 산책 중에 폰을 쓰든, 웹 브라우저에서 작업하든, 이제 백그라운드에서 돌아가는 강력한 코딩 에이전트를 바로 시작할 수 있어.
작업이 끝나면 Cursor에서 이어받아 변경사항을 리뷰하고 머지하거나, 팀과 협업할 수 있도록 링크를 공유해.

[cursor.com/agents](https://cursor.com/agents)에서 시작해봐.

<Frame><img src="https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-1.png?fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=79c7d14df82cfcae369bccb8a1431cf3" alt="Cursor web agent interface" data-og-width="4095" width="4095" data-og-height="2048" height="2048" data-path="images/webagent/cursor-web-1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-1.png?w=280&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=099c28633151e6c20eebc7fe03b3d420 280w, https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-1.png?w=560&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=452e0216c7e270d760072032f1e2b36d 560w, https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-1.png?w=840&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=baaa4a73d4822b5daa293814dc201d37 840w, https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-1.png?w=1100&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=8c5255fbf16aa60924e78a8285afb95d 1100w, https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-1.png?w=1650&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=7cc5a04ff6b24ad4ce0cfb4a35a9919c 1650w, https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-1.png?w=2500&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=f5f1b15fa508e20f89a4089f81417774 2500w" /></Frame>

<div id="getting-started">
  ## 시작하기
</div>

<div id="quick-setup">
  ### 빠른 설정
</div>

1. **웹 앱 열기**: 어떤 기기에서든 [cursor.com/agents](https://cursor.com/agents)로 이동
2. **로그인**: Cursor 계정으로 로그인
3. **GitHub 연결**: 리포지토리 액세스를 위해 GitHub 계정 연동
4. **첫 에이전트 시작**: 작업을 입력하고 에이전트가 실행되는 걸 확인

<div id="mobile-installation">
  ### 모바일 설치
</div>

모바일에서 최상의 경험을 원하면 Cursor를 PWA(Progressive Web App)로 설치해:

* **iOS**: Safari에서 [cursor.com/agents](https://cursor.com/agents)를 열고 공유 버튼을 탭한 다음 "홈 화면에 추가" 선택
* **Android**: Chrome에서 URL을 열고 메뉴를 탭한 다음 "홈 화면에 추가" 또는 "앱 설치" 선택

<Tip>
  PWA로 설치하면 다음과 같은 네이티브에 가까운 경험을 제공해: - 전체 화면
  인터페이스 - 더 빠른 시작 - 홈 화면 앱 아이콘
</Tip>

<div id="working-across-devices">
  ## 여러 기기에서 작업하기
</div>

Web 및 Mobile Agent는 데스크톱 워크플로와 맞물려 동작하도록 설계됐어. IDE에서 에이전트 작업을 이어가려면 "Open in Cursor"를 클릭해.

<Frame><img src="https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-2.png?fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=352140fd4bf3f3d98a1e1b9f4a995cad" alt="검토 및 인수인계" data-og-width="4095" width="4095" data-og-height="2048" height="2048" data-path="images/webagent/cursor-web-2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-2.png?w=280&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=eedd50318503fd3d3961b6da27a386d9 280w, https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-2.png?w=560&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=fd8c730cf62a0af6f873945a6a23b90b 560w, https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-2.png?w=840&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=ac537cc639471556f1afa0e09425ef30 840w, https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-2.png?w=1100&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=d512cddda6890c0749a7ad6396682def 1100w, https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-2.png?w=1650&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=e208297f414976bcfeea6850b39e8abb 1650w, https://mintcdn.com/cursor/kWfPDXl84scQFWmx/images/webagent/cursor-web-2.png?w=2500&fit=max&auto=format&n=kWfPDXl84scQFWmx&q=85&s=54683ff7f25750fdc788e87c30bb6d6d 2500w" /></Frame>

<div id="team-collaboration">
  ### 팀 협업
</div>

* **공유 액세스**: 팀원이랑 링크를 공유해 에이전트 실행에 같이 협업해.
* **리뷰 프로세스**: 협업자가 diff를 리뷰하고 피드백을 남길 수 있어.
* **Pull Request 관리**: 웹 인터페이스에서 Pull Request를 생성, 리뷰, 머지할 수 있어.

<div id="slack-integration">
  ### Slack 연동
</div>

Slack에서 `@Cursor`를 멘션해 바로 에이전트를 트리거하고, 웹이나 모바일에서 에이전트를 시작할 때 완료 알림을 Slack으로 받도록 선택할 수 있어.

<Card title="Slack에서 Cursor 사용하기" icon="slack" href="/ko/slack">
  Slack 연동 설정과 사용법, 에이전트 트리거 및 알림 받는 방법을
  더 알아봐.
</Card>

<div id="pricing">
  ## 요금제
</div>

웹·모바일 에이전트는 백그라운드 에이전트와 동일한 요금 모델을 써.

[백그라운드 에이전트 요금](/ko/account/pricing#background-agent)에 대해 더 알아보기.

<div id="troubleshooting">
  ## 문제 해결
</div>

<AccordionGroup>
  <Accordion title="에이전트 실행이 시작되지 않음">
    * 로그인했고 GitHub 계정을 연결했는지 확인해 - 대상 리포지토리에 필요한 권한이 있는지 확인해 -
      사용량 기반 과금이 켜진 Pro 체험판 또는 유료 플랜을 쓰고 있어야 해. 사용량 기반 과금을
      켜려면 [Dashboard](https://www.cursor.com/dashboard?tab=settings)의 설정 탭으로 가.
  </Accordion>

  <Accordion title="모바일에서 에이전트 실행이 안 보여">
    페이지를 새로고침하거나 브라우저 캐시를 지워봐. 여러 기기에서 같은 계정을 쓰는지도 확인해.
  </Accordion>

  <Accordion title="Slack 연동이 안 됨">
    워크스페이스 관리자가 Cursor Slack 앱을 설치했고, 네가 필요한 권한을 갖고 있는지 확인해.
  </Accordion>
</AccordionGroup>



# Bugbot
Source: https://docs.cursor.com/ko/bugbot

풀 리퀘스트용 AI 코드 리뷰

Bugbot은 풀 리퀘스트를 리뷰하고 버그, 보안 취약점, 코드 품질 문제를 찾아줘.

<Tip>
  Bugbot엔 무료 플랜이 있어: 모든 사용자가 매달 제한된 횟수의 무료 PR 리뷰를 받아. 한도에 도달하면 다음 결제 주기까지 리뷰가 잠시 멈춰. 표준 남용 방지 가드레일이 적용되는 무제한 리뷰를 위해 언제든 14일 무료 Pro 체험으로 업그레이드할 수 있어.
</Tip>

<Frame>
  <video src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/bugbot/bugbot-report-cropped.mp4?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=013060fbd22f397ac81f2c32bb8b6b14" alt="PR에 댓글을 남기는 Bugbot" autoPlay loop muted playsInline controls data-path="images/bugbot/bugbot-report-cropped.mp4" />
</Frame>

<div id="how-it-works">
  ## 작동 방식
</div>

Bugbot은 PR diff를 분석해서 설명과 수정 제안을 담은 댓글을 남겨. 각 PR이 업데이트될 때마다 자동으로 실행되거나, 수동으로 트리거해서 실행할 수도 있어.

* PR이 업데이트될 때마다 **자동 리뷰** 실행
* 어떤 PR이든 `cursor review` 또는 `bugbot run` 댓글로 **수동 트리거**
* **Fix in Cursor** 링크로 이슈를 Cursor에서 바로 열 수 있어
* **Fix in Web** 링크로 이슈를 [cursor.com/agents](https://cursor.com/agents)에서 바로 열 수 있어

<div id="setup">
  ## 설정
</div>

Cursor 관리자 권한과 GitHub 조직 관리자 권한이 필요해.

1. [cursor.com/dashboard](https://cursor.com/dashboard?tab=bugbot)로 가
2. Bugbot 탭으로 이동해
3. `Connect GitHub` 클릭해 (이미 연결돼 있다면 `Manage Connections`)
4. GitHub 설치 흐름을 따라가
5. 대시보드로 돌아와서 특정 리포지토리에서 Bugbot을 활성화해

<Frame>
  <video src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/bugbot/bugbot-install.mp4?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=75745d4464b183c306a44571db86a0c4" alt="Bugbot GitHub 설정" autoPlay loop muted playsInline controls data-path="images/bugbot/bugbot-install.mp4" />
</Frame>

<div id="configuration">
  ## 구성
</div>

<Tabs defaultValue="Team">
  <Tab title="Individual">
    ### 리포지토리 설정

    설치 목록에서 리포지토리별로 Bugbot을 켜거나 꺼. Bugbot은 네가 만든 PR에서만 돌아가.

    ### 개인 설정

    * 댓글로 `cursor review` 또는 `bugbot run`을 달아 **언급됐을 때만 실행**
    * 이후 커밋은 건너뛰고 PR당 **한 번만 실행**
  </Tab>

  <Tab title="Team">
    ### 리포지토리 설정

    팀 관리자는 리포지토리별로 Bugbot을 켜고, 리뷰어 허용/차단 목록을 설정하며, 다음을 구성할 수 있어:

    * 설치 단위로 PR당 **한 번만 실행**, 이후 커밋은 건너뛰기
    * Bugbot이 코드 라인에 직접 댓글을 남기지 않도록 **인라인 리뷰 비활성화**

    Bugbot은 팀 소속 여부와 관계없이 활성화된 리포지토리의 모든 기여자에게 실행돼.

    ### 개인 설정

    팀 구성원은 자신의 PR에 대해 설정을 재정의할 수 있어:

    * 댓글로 `cursor review` 또는 `bugbot run`을 달아 **언급됐을 때만 실행**
    * 이후 커밋은 건너뛰고 PR당 **한 번만 실행**
    * 초안 풀 리퀘스트도 자동 리뷰에 포함되도록 **드래프트 PR에서 리뷰 활성화**
  </Tab>
</Tabs>

<div id="analytics">
  ### 분석
</div>

<Frame>
  <img src="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/bugbot/bugbot-dashboard.png?fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=0b09bc0e61d1c92017c3ca42957c70e1" alt="Bugbot 대시보드" data-og-width="1832" width="1832" data-og-height="2022" height="2022" data-path="images/bugbot/bugbot-dashboard.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/bugbot/bugbot-dashboard.png?w=280&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=fe3c6151118fa404a0a5a100968649cf 280w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/bugbot/bugbot-dashboard.png?w=560&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=7a602dfdaa6f737dc6d5010ea90a74b8 560w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/bugbot/bugbot-dashboard.png?w=840&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=6a21a6cb4b32248fb2b8cbea9afb8bcc 840w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/bugbot/bugbot-dashboard.png?w=1100&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=27df9beda1ee9efc84e6f2c339ff1076 1100w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/bugbot/bugbot-dashboard.png?w=1650&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=80cb6507ca96d1c2aa74bcc30170b517 1650w, https://mintcdn.com/cursor/GnTEh_6SKR7li-hM/images/bugbot/bugbot-dashboard.png?w=2500&fit=max&auto=format&n=GnTEh_6SKR7li-hM&q=85&s=ce35818f10c462b16b2d697519557019 2500w" />
</Frame>

<div id="rules">
  ## 규칙
</div>

프로젝트별 리뷰 컨텍스트를 제공하려면 `.cursor/BUGBOT.md` 파일을 만들어. Bugbot은 항상 루트의 `.cursor/BUGBOT.md` 파일과 변경된 파일에서 상위 디렉터리로 올라가며 찾은 모든 추가 파일을 포함해.

```
project/
  .cursor/BUGBOT.md          # 항상 포함됨(프로젝트 전체 규칙)
  backend/
    .cursor/BUGBOT.md        # 백엔드 파일 검토 시 포함됨
    api/
      .cursor/BUGBOT.md      # API 파일 검토 시 포함됨
  frontend/
    .cursor/BUGBOT.md        # 프런트엔드 파일 검토 시 포함됨
```

<AccordionGroup>
  <Accordion title="예시 .cursor/BUGBOT.md">
    ```markdown  theme={null}
    # 프로젝트 리뷰 가이드라인

    ## 보안 중점 영역

    - API 엔드포인트에서 사용자 입력 검증
    - 데이터베이스 쿼리의 SQL 인젝션 취약점 점검
    - 보호된 라우트에 적절한 인증 보장

    ## 아키텍처 패턴

    - 서비스에 의존성 주입 사용
    - 데이터 접근에 리포지토리 패턴 적용
    - 커스텀 에러 클래스로 적절한 오류 처리 구현

    ## 흔한 문제

    - React 컴포넌트의 메모리 누수(useEffect 정리 함수 확인)
    - UI 컴포넌트에 오류 경계 누락
    - 일관되지 않은 네이밍 컨벤션(함수는 camelCase 사용)

    ```
  </Accordion>
</AccordionGroup>

<div id="pricing">
  ## 요금제
</div>

Bugbot은 두 가지 요금제를 제공해: **Free**와 **Pro**.

<div id="free-tier">
  ### 무료 플랜
</div>

모든 사용자는 매달 제한된 횟수의 무료 PR 리뷰를 받게 돼. 팀이라면 각 팀원마다 자신의 무료 리뷰가 제공돼. 한도에 도달하면 다음 결제 주기까지 리뷰가 일시 중지돼. 언제든지 14일 무료 Pro 체험으로 업그레이드해서 무제한 리뷰를 쓸 수 있어.

<div id="pro-tier">
  ### 프로 티어
</div>

<Tabs defaultValue="Teams">
  <Tab title="Individuals">
    ### 정액제

    모든 리포지토리에서 한 달 최대 200개의 PR에 대해 Bugbot 무제한 리뷰: 월 \$40.

    ### 시작하기

    계정 설정에서 구독해.
  </Tab>

  <Tab title="Teams">
    ### 사용자별 과금

    팀은 사용자 1명당 월 \$40로 무제한 리뷰를 이용해.

    한 달 동안 Bugbot이 리뷰한 PR을 작성한 사람을 사용자로 집계해.

    모든 라이선스는 각 청구 주기 시작 시 반납되고, 선착순으로 재할당돼. 어떤 사용자가 한 달 동안 Bugbot이 리뷰한 PR을 하나도 작성하지 않으면, 그 좌석은 다른 사용자가 쓸 수 있어.

    ### 좌석 한도

    팀 관리자는 비용 관리를 위해 월별 Bugbot 좌석 최대치를 설정할 수 있어.

    ### 시작하기

    팀 대시보드에서 구독해 결제를 활성화해.

    ### 오남용 방지

    오남용을 막기 위해, 모든 Bugbot 라이선스에는 한 달 200개의 풀 리퀘스트라는 공유 상한이 있어. 한 달에 200개 이상이 필요하면 [hi@cursor.com](mailto:hi@cursor.com)으로 연락해 줘. 기꺼이 도와줄게.

    예를 들어, 팀에 사용자가 100명이라면, 조직은 처음에 한 달에 20,000개의 풀 리퀘스트를 리뷰할 수 있어. 그 한도에 자연스럽게 도달했다면 우리에게 연락해 줘. 한도를 높여줄게.
  </Tab>
</Tabs>

<div id="troubleshooting">
  ## 문제 해결
</div>

Bugbot이 작동하지 않을 때:

1. 자세한 로그와 요청 ID를 확인하려면 `cursor review verbose=true` 또는 `bugbot run verbose=true`를 **주석으로 추가해서 verbose 모드 켜기**
2. **권한 확인**해서 Bugbot이 저장소에 접근할 수 있는지 확인하기
3. **설치 확인**해서 GitHub 앱이 설치되고 활성화되어 있는지 확인하기

문제 신고할 때는 verbose 모드에서 나온 요청 ID를 꼭 포함해줘.

<div id="faq">
  ## FAQ
</div>

<AccordionGroup>
  <Accordion title="Bugbot는 privacy mode를 준수해?">
    응, Bugbot은 Cursor랑 같은 프라이버시 준수 기준을 따르고, 다른 Cursor 요청이랑 동일한 방식으로 데이터를 처리해.
  </Accordion>

  <Accordion title="무료 티어 한도에 도달하면 어떻게 돼?">
    월간 무료 티어 한도에 도달하면 다음 결제 주기까지 Bugbot 리뷰가 잠시 멈춰. 무제한 리뷰를 쓰려면 14일 무료 Pro 체험으로 업그레이드할 수 있어(표준 오남용 방지 가이드 적용).
  </Accordion>
</AccordionGroup>

```
```



# Code Review
Source: https://docs.cursor.com/ko/cli/cookbook/code-review

Cursor CLI로 pull request를 자동 리뷰하고 피드백을 남기는 GitHub Actions 워크플로 구축

이 튜토리얼에선 GitHub Actions에서 Cursor CLI로 코드 리뷰를 설정하는 방법을 보여줄게. 워크플로는 pull request를 분석하고, 문제를 찾아내며, 댓글로 피드백을 남겨.

<Tip>
  대부분의 사용자에겐 [Bugbot](/ko/bugbot)을 쓰는 걸 추천해. Bugbot은 별도 설정 없이 관리형 자동 코드 리뷰를 제공해. 이 CLI 방식은 기능을 탐색하거나 고급 커스터마이징이 필요할 때 유용해.
</Tip>

<div className="space-y-4">
  <Expandable title="전체 워크플로 파일">
    ```yaml cursor-code-review.yml theme={null}
    name: 코드 리뷰

    on:
      pull_request:
        types: [opened, synchronize, reopened, ready_for_review]

    permissions:
      pull-requests: write
      contents: read
      issues: write

    jobs:
      code-review:
        runs-on: ubuntu-latest
        # 드래프트 PR은 자동 코드 리뷰 건너뛰기
        if: github.event.pull_request.draft == false
        steps:
          - name: 리포지토리 체크아웃
            uses: actions/checkout@v4
            with:
              fetch-depth: 0
              ref: ${{ github.event.pull_request.head.sha }}

          - name: Cursor CLI 설치
            run: |
              curl https://cursor.com/install -fsS | bash
              echo "$HOME/.cursor/bin" >> $GITHUB_PATH

          - name: git 사용자 정보 설정
            run: |
              git config user.name "Cursor 에이전트"
              git config user.email "cursoragent@cursor.com"

          - name: 자동 코드 리뷰 실행
            env:
              CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
              MODEL: gpt-5
              GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              BLOCKING_REVIEW: ${{ vars.BLOCKING_REVIEW || 'false' }}
            run: |
              cursor-agent --force --model "$MODEL" --output-format=text --print 'GitHub Actions 러너에서 자동 코드 리뷰를 수행 중이야. gh CLI는 GH_TOKEN으로 인증되어 있고 사용 가능해. 풀 리퀘스트에 코멘트를 남길 수 있어.

              컨텍스트:
              - 리포지토리: ${{ github.repository }}
              - PR 번호: ${{ github.event.pull_request.number }}
              - PR 헤드 SHA: ${{ github.event.pull_request.head.sha }}
              - PR 베이스 SHA: ${{ github.event.pull_request.base.sha }}
              - 차단 리뷰: ${{ env.BLOCKING_REVIEW }}

              목표:
              1) 기존 리뷰 코멘트를 다시 확인하고 해결됐으면 resolved로 답장해.
              2) 현재 PR diff를 리뷰하고 명확하고 심각도가 높은 이슈만 표시해.
              3) 변경된 라인에만 아주 짧은 인라인 코멘트(1~2문장)와 끝에 간단한 요약을 남겨.

              절차:
              - 기존 코멘트 가져오기: gh pr view --json comments
              - diff 가져오기: gh pr diff
              - 인라인 위치 계산을 위한 패치 포함 변경 파일 가져오기: gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files --paginate --jq '.[] | {filename,patch}'
              - 각 이슈에 대한 정확한 인라인 앵커 계산(파일 경로 + diff 위치). 코멘트는 반드시 diff의 변경된 라인에 인라인으로 달고, 최상위 코멘트로 달면 안 돼.
              - 이 봇이 작성한 이전의 최상위 "문제 없음" 스타일 코멘트를 감지해(본문이 "✅ no issues", "No issues found", "LGTM"과 유사한 경우 매칭).
              - 이번 실행에서 이슈가 발견되고 과거 "문제 없음" 코멘트가 있으면:
                - 혼란을 피하기 위해 제거하는 걸 우선해:
                  - 최상위 해당 코멘트 삭제 시도: gh api -X DELETE repos/${{ github.repository }}/issues/comments/<comment_id>
                  - 삭제가 불가하면 GraphQL(minimizeComment)로 최소화하거나 "[Superseded by new findings]" 접두사를 붙여 편집해.
                - 삭제/최소화 모두 불가하면 이렇게 답장해: "⚠️ 대체됨: 최신 커밋에서 이슈가 발견됐어"
              - 이전에 보고된 이슈가 인접한 변경으로 해결된 것 같으면, 이렇게 답장해: ✅ 최근 변경으로 이 이슈가 해결된 것으로 보여
              - 다음만 분석:
                - null/undefined 역참조
                - 리소스 누수(닫히지 않은 파일 또는 연결)
                - 인젝션(SQL/XSS)
                - 동시성/경쟁 상태
                - 중요 작업의 오류 처리 누락
                - 잘못된 동작을 유발하는 명백한 로직 오류
                - 측정 가능한 영향이 있는 명확한 성능 안티패턴
                - 명백한 보안 취약점
              - 중복 방지: 동일하거나 인접한 라인에 유사한 피드백이 이미 있으면 건너뛰어.

              코멘트 규칙:
              - 인라인 코멘트 최대 10개; 가장 중요한 이슈에 우선순위를 둬
              - 코멘트당 하나의 이슈; 정확히 변경된 라인에 배치해
              - 모든 이슈 코멘트는 반드시 인라인(PR diff의 파일과 위치에 고정)
              - 자연스러운 톤으로 구체적이고 실행 가능하게; 자동화나 확신도 언급 금지
              - 이모지 사용: 🚨 중대 🔒 보안 ⚡ 성능 ⚠️ 로직 ✅ 해결 ✨ 개선

              제출:
              - 보고할 이슈가 없고 기존의 "문제 없음" 최상위 코멘트가 이미 있으면(예: "✅ no issues", "No issues found", "LGTM") 새 코멘트를 제출하지 마. 중복을 피하기 위해 건너뛰어.
              - 보고할 이슈가 없고 이전 "문제 없음" 코멘트도 없으면, 간단한 요약 코멘트 하나로 문제 없음을 알려.
              - 보고할 이슈가 있고 이전 "문제 없음" 코멘트가 있으면, 새 리뷰 제출 전에 그 코멘트를 삭제/최소화/대체됨으로 표시해.
              - 보고할 이슈가 있으면, 인라인 코멘트만 포함한 리뷰 하나와 선택적 간결 요약 본문을 제출해. 인라인을 보장하려면 GitHub Reviews API를 사용해:
                - 다음 형식의 코멘트 JSON 배열을 구성: [{ "path": "<file>", "position": <diff_position>, "body": "..." }]
                - 다음으로 제출: gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews -f event=COMMENT -f body="$SUMMARY" -f comments='[$COMMENTS_JSON]'
              - 사용 금지: gh pr review --approve 또는 --request-changes

              차단 동작:
              - BLOCKING_REVIEW가 true이고 🚨 또는 🔒 이슈가 하나라도 올라왔으면: echo "CRITICAL_ISSUES_FOUND=true" >> $GITHUB_ENV
              - 그 외에는: echo "CRITICAL_ISSUES_FOUND=false" >> $GITHUB_ENV
              - 마지막에 항상 CRITICAL_ISSUES_FOUND를 설정해
              '

          - name: 차단 리뷰 결과 확인
            if: env.BLOCKING_REVIEW == 'true'
            run: |
              echo "중대한 이슈가 있는지 확인 중..."
              echo "CRITICAL_ISSUES_FOUND: ${CRITICAL_ISSUES_FOUND:-unset}"

              if [ "${CRITICAL_ISSUES_FOUND:-false}" = "true" ]; then
                echo "❌ 중대한 이슈가 발견됐고 차단 리뷰가 활성화되어 있어. 워크플로를 실패 처리할게."
                exit 1
              else
                echo "✅ 차단되는 이슈는 발견되지 않았어."
              fi
    ```
  </Expandable>

  <Frame>
    <img src="https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/comment.png?fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=31c7e4b54276532df8010645686ebbbc" alt="풀 리퀘스트에서 인라인 코멘트를 표시하는 자동 코드 리뷰" data-og-width="2920" width="2920" data-og-height="1272" height="1272" data-path="images/cli/cookbook/code-review/comment.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/comment.png?w=280&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=25e552210fa8425a10ff459bf4cd6006 280w, https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/comment.png?w=560&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=234bf271bc595e763549c4f04d2e6fbb 560w, https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/comment.png?w=840&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=b6f6d1444de7fe0197e3d35fa35955e8 840w, https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/comment.png?w=1100&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=300314314f5071b77f735460be33985f 1100w, https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/comment.png?w=1650&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=10e4db857ee84c55d17222cef492611d 1650w, https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/comment.png?w=2500&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=e65add70ffebfeb9ad05c9bb19a5f4e1 2500w" />
  </Frame>
</div>

<div id="configure-authentication">
  ## 인증 구성
</div>

GitHub Actions에서 Cursor CLI를 인증하려면 [API 키랑 리포지토리 시크릿을 설정](/ko/cli/github-actions#authentication)해.

<div id="set-up-agent-permissions">
  ## 에이전트 권한 설정
</div>

에이전트가 수행할 수 있는 작업을 제어할 설정 파일을 만들어. 이렇게 하면 코드 푸시나 풀 리퀘스트 생성 같은 의도치 않은 작업을 막을 수 있어.

리포지토리 루트에 `.cursor/cli.json`을 만들어:

```json  theme={null}
{
  "permissions": {
    "deny": [
      "Shell(git push)",
      "Shell(gh pr create)",
      "Write(**)"
    ]
  }
}
```

이 구성은 에이전트가 파일을 읽고 댓글을 달 때 GitHub CLI를 쓰게 해주지만, 저장소에는 변경을 못 하게 막아. 더 많은 구성 옵션은 [permissions reference](/ko/cli/reference/permissions)를 확인해.

<div id="build-the-github-actions-workflow">
  ## GitHub Actions 워크플로 빌드하기
</div>

이제 워크플로를 단계별로 만들어 보자.

<div id="set-up-the-workflow-trigger">
  ### 워크플로 트리거 설정
</div>

`.github/workflows/cursor-code-review.yml`를 만들고, pull request에서 실행되도록 설정해:

```yaml  theme={null}
name: Cursor 코드 리뷰

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

jobs:
  code-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
```

<div id="checkout-the-repository">
  ### 리포지토리 체크아웃
</div>

Pull request 코드를 가져오려면 checkout 단계를 추가해:

```yaml  theme={null}
- name: 저장소 체크아웃
  uses: actions/checkout@v4
  with:
    fetch-depth: 0
    ref: ${{ github.event.pull_request.head.sha }}
```

<div id="install-cursor-cli">
  ### Cursor CLI 설치
</div>

CLI 설치 단계를 추가해:

```yaml  theme={null}
- name: Cursor CLI 설치
  run: |
    curl https://cursor.com/install -fsS | bash
    echo "$HOME/.cursor/bin" >> $GITHUB_PATH
```

<div id="configure-the-review-agent">
  ### 리뷰 에이전트 구성하기
</div>

전체 리뷰 단계를 구현하기 전에, 리뷰 프롬프트의 구성을 먼저 이해해 보자. 이 섹션은 에이전트가 어떻게 동작해야 하는지 설명해:

**목표**:
에이전트가 현재 PR diff를 검토해 명확하고 심각도가 높은 이슈만 표시하고, 변경된 라인에만 매우 짧은 인라인 코멘트(1\~2문장)를 남긴 뒤 마지막에 간단한 요약을 추가하길 원해. 이렇게 하면 신호 대 잡음 비율이 적절하게 유지돼.

**형식**:
코멘트는 짧고 핵심만 담아야 해. 스캔을 빠르게 하려고 이모지를 사용하고, 마지막에 전체 리뷰에 대한 상위 수준 요약을 붙여.

**제출**:
리뷰가 끝나면, 리뷰에서 발견된 내용을 바탕으로 에이전트가 짧은 코멘트를 포함해야 해. 에이전트는 인라인 코멘트와 간결한 요약을 담은 하나의 리뷰로 제출해야 해.

**엣지 케이스**:
다음을 처리해야 해:

* 기존 코멘트가 해결됨: 해결된 경우 에이전트가 완료로 표시해야 해
* 중복 방지: 동일하거나 인접한 라인에 유사한 피드백이 이미 있으면 코멘트 작성을 건너뛰어야 해

**최종 프롬프트**:
완성된 프롬프트는 이러한 동작 요구사항을 모두 결합해 집중적이고 실행 가능한 피드백을 만들어

이제 리뷰 에이전트 단계를 구현해 보자:

```yaml  theme={null}
- name: 코드 리뷰 수행
  env:
    CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
    GH_TOKEN: ${{ github.token }}
  run: |
    cursor-agent --force --model "$MODEL" --output-format=text --print "너는 GitHub Actions 러너에서 자동 코드 리뷰를 수행하고 있어. gh CLI는 GH_TOKEN으로 인증되어 있어. 풀 리퀘스트에 댓글을 남길 수 있어.
    
    Context:
    - Repo: ${{ github.repository }}
    - PR Number: ${{ github.event.pull_request.number }}
    - PR Head SHA: ${{ github.event.pull_request.head.sha }}
    - PR Base SHA: ${{ github.event.pull_request.base.sha }}
    
    Objectives:
    1) 기존 리뷰 댓글을 재확인하고 해결되었으면 resolved로 답장하기
    2) 현재 PR diff를 검토하고 명확하며 심각도가 높은 이슈만 표시하기
    3) 변경된 줄에만 매우 짧은 인라인 댓글(1~2문장)을 남기고 끝에 간단한 요약 추가하기
    
    Procedure:
    - 기존 댓글 가져오기: gh pr view --json comments
    - diff 가져오기: gh pr diff
    - 이전에 보고된 이슈가 인접한 변경으로 해결된 것으로 보이면 이렇게 답장: ✅ 최근 변경으로 이 이슈가 해결된 것으로 보입니다
    - 중복 방지: 동일하거나 유사한 피드백이 같은 줄 또는 인근 줄에 이미 있으면 건너뛰기
    
    Commenting rules:
    - 인라인 댓글은 최대 10개; 가장 치명적인 이슈에 우선순위 두기
    - 댓글당 하나의 이슈; 정확히 변경된 줄에 달기
    - 자연스럽고 구체적이며 실행 가능하게; 자동화 여부나 높은 확신 같은 표현은 언급하지 않기
    - 이모지 사용: 🚨 Critical 🔒 Security ⚡ Performance ⚠️ Logic ✅ Resolved ✨ Improvement
    
    Submission:
    - 인라인 댓글과 간결한 요약을 포함한 단일 리뷰 제출
    - 다음만 사용: gh pr review --comment
    - 다음은 사용하지 않기: gh pr review --approve 또는 --request-changes"
```

```text  theme={null}
.
├── .cursor/
│   └── cli.json
├── .github/
│   └── workflows/
│       └── cursor-code-review.yml
```

<div id="test-your-reviewer">
  ## 리뷰어 테스트하기
</div>

워크플로가 제대로 동작하는지, 에이전트가 이모지 피드백과 함께 리뷰 댓글을 남기는지 확인하려고 테스트용 pull request를 만들어봐.

<Frame>
  <img src="https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/github-actions.png?fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=aa989eb5b7520e6718a48afd8daa70d9" alt="특정 줄에 대한 인라인 피드백과 이모지가 포함된 자동 리뷰 댓글이 표시된 pull request" data-og-width="1250" width="1250" data-og-height="704" height="704" data-path="images/cli/cookbook/code-review/github-actions.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/github-actions.png?w=280&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=9f2e324beb1cccb8052dcd0682323e47 280w, https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/github-actions.png?w=560&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=f08497ddb17921f4bb4638ef4eec3379 560w, https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/github-actions.png?w=840&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=3c869c0ed8eb8b5743dd3821e57cd406 840w, https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/github-actions.png?w=1100&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=19e98ed953f4cc17b2c578ce543cf88d 1100w, https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/github-actions.png?w=1650&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=4d9f47472af81254bd09b5f6234fc97f 1650w, https://mintcdn.com/cursor/KODIqSiRh6LRGwl9/images/cli/cookbook/code-review/github-actions.png?w=2500&fit=max&auto=format&n=KODIqSiRh6LRGwl9&q=85&s=f3af19e3edd7f8bbbb77ba6566d8e183 2500w" />
</Frame>

<div id="next-steps">
  ## 다음 단계
</div>

이제 자동 코드 리뷰 시스템이 잘 돌아가. 다음 개선을 고려해봐:

* [CI 실패 수정](/ko/cli/cookbook/fix-ci)을 위한 추가 워크플로 설정
* 브랜치별로 서로 다른 리뷰 레벨 구성
* 팀의 기존 코드 리뷰 프로세스와 통합
* 파일 유형이나 디렉터리별로 에이전트 동작 커스터마이즈

<Expandable title="고급: 차단형 리뷰">
  치명적인 이슈가 발견되면 워크플로를 실패로 처리해서, 해결될 때까지 pull request가 머지되지 않게 설정할 수 있어.

  **프롬프트에 차단 동작 추가**

  먼저, 리뷰 에이전트 단계에 `BLOCKING_REVIEW` 환경 변수를 포함하고, 이 차단 동작을 프롬프트에 추가해:

  ```
  Blocking behavior:
  - If BLOCKING_REVIEW is true and any 🚨 or 🔒 issues were posted: echo "CRITICAL_ISSUES_FOUND=true" >> $GITHUB_ENV
  - Otherwise: echo "CRITICAL_ISSUES_FOUND=false" >> $GITHUB_ENV
  - Always set CRITICAL_ISSUES_FOUND at the end
  ```

  **차단 확인 단계 추가**

  그다음 코드 리뷰 단계 뒤에 이 새 단계를 추가해:

  ```yaml  theme={null}
        - name: Check blocking review results
          if: env.BLOCKING_REVIEW == 'true'
          run: |
            echo "Checking for critical issues..."
            echo "CRITICAL_ISSUES_FOUND: ${CRITICAL_ISSUES_FOUND:-unset}"

            if [ "${CRITICAL_ISSUES_FOUND:-false}" = "true" ]; then
              echo "❌ Critical issues found and blocking review is enabled. Failing the workflow."
              exit 1
            else
              echo "✅ No blocking issues found."
            fi
  ```
</Expandable>



# CI 실패 해결
Source: https://docs.cursor.com/ko/cli/cookbook/fix-ci

GitHub Actions에서 Cursor CLI로 저장소의 CI 이슈 해결

GitHub Actions에서 Cursor CLI로 CI 실패를 해결해. 이 워크플로는 실패를 분석하고, 최소 변경으로 정확히 고치며, 빠른 PR 생성 링크가 포함된 픽스 브랜치를 만들어.

이 워크플로는 이름으로 특정 워크플로를 모니터링해. 실제 CI 워크플로 이름에 맞게 `workflows` 목록을 업데이트해.

<CodeGroup>
  ```yaml auto-fix-ci.yml theme={null}
  name: Fix CI Failures

  on:
    workflow_run:
      workflows: [Test]
      types: [completed]

  permissions:
    contents: write
    pull-requests: write
    actions: read

  jobs:
    attempt-fix:
      if: >-
        ${{ github.event.workflow_run.conclusion == 'failure' && github.event.workflow_run.name != 'Fix CI Failures' }}
      runs-on: ubuntu-latest
      steps:
        - name: Checkout repository
          uses: actions/checkout@v4
          with:
            fetch-depth: 0

        - name: Install Cursor CLI
          run: |
            curl https://cursor.com/install -fsS | bash
            echo "$HOME/.cursor/bin" >> $GITHUB_PATH

        - name: Configure git identity
          run: |
            git config user.name "Cursor Agent"
            git config user.email "cursoragent@cursor.com"

        - name: Fix CI failure
          env:
            CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
            MODEL: gpt-5
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            BRANCH_PREFIX: ci-fix
          run: |
            cursor-agent -p "You are operating in a GitHub Actions runner.

            The GitHub CLI is available as `gh` and authenticated via `GH_TOKEN`. Git is available. You have write access to repository contents and can comment on pull requests, but you must not create or edit PRs directly.

            # Context:
            - Repo: ${{ github.repository }}
            - Owner: ${{ github.repository_owner }}
            - Workflow Run ID: ${{ github.event.workflow_run.id }}
            - Workflow Run URL: ${{ github.event.workflow_run.html_url }}
            - Fix Branch Prefix: ${{ env.BRANCH_PREFIX }}

            # Goal:
            - Implement an end-to-end CI fix flow driven by the failing PR, creating a separate persistent fix branch and proposing a quick-create PR back into the original PR's branch.

            # Requirements:
            1) Identify the PR associated with the failed workflow run and determine its base and head branches. Let HEAD_REF be the PR's head branch (the contributor/origin branch).
            2) Maintain a persistent fix branch for this PR head using the Fix Branch Prefix from Context. Create it if missing, update it otherwise, and push changes to origin.
            3) Attempt to resolve the CI failure by making minimal, targeted edits consistent with the repo's style. Keep changes scoped and safe.
            4) You do NOT have permission to create PRs. Instead, post or update a single natural-language PR comment (1–2 sentences) that briefly explains the CI fix and includes an inline compare link to quick-create a PR.

            # Inputs and conventions:
            - Use `gh api`, `gh run view`, `gh pr view`, `gh pr diff`, `gh pr list`, `gh run download`, and git commands as needed to discover the failing PR and branches.
            - Avoid duplicate comments; if a previous bot comment exists, update it instead of posting a new one.
            - If no actionable fix is possible, make no changes and post no comment.

            # Deliverables when updates occur:
            - Pushed commits to the persistent fix branch for this PR head.
            - A single natural-language PR comment on the original PR that includes the inline compare link above.
            " --force --model "$MODEL" --output-format=text

  ```
</CodeGroup>



# Secret Audit
Source: https://docs.cursor.com/ko/cli/cookbook/secret-audit

GitHub Actions에서 Cursor CLI로 리포지토리의 시크릿 감사 수행

Cursor CLI로 리포지토리의 보안 취약점과 시크릿 노출을 감사해. 이 워크플로는 잠재적 시크릿을 스캔하고, 위험한 워크플로 패턴을 탐지하며, 보안 수정안을 제안해.

<CodeGroup>
  ```yaml auto-secret-audit.yml theme={null}
  name: Secrets Audit

  on:
    schedule:
      - cron: "0 4 * * *"
    workflow_dispatch:

  permissions:
    contents: write
    pull-requests: write
    actions: read

  jobs:
    secrets-audit:
      runs-on: ubuntu-latest
      steps:
        - name: Checkout repository
          uses: actions/checkout@v4
          with:
            fetch-depth: 0

        - name: Install Cursor CLI
          run: |
            curl https://cursor.com/install -fsS | bash
            echo "$HOME/.cursor/bin" >> $GITHUB_PATH

        - name: Configure git identity
          run: |
            git config user.name "Cursor Agent"
            git config user.email "cursoragent@cursor.com"

        - name: Scan and propose hardening
          env:
            CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
            MODEL: gpt-5
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            BRANCH_PREFIX: audit
          run: |
            cursor-agent -p "You are operating in a GitHub Actions runner.

            The GitHub CLI is available as `gh` and authenticated via `GH_TOKEN`. Git is available. You have write access to repository contents and can comment on pull requests, but you must not create or edit PRs directly.

            # Context:
            - Repo: ${{ github.repository }}
             - Hardening Branch Prefix: ${{ env.BRANCH_PREFIX }}

            # Goal:
            - Perform a repository secrets exposure and workflow hardening audit on a schedule, and propose minimal safe fixes.

            # Requirements:
            1) Scan for potential secrets in tracked files and recent history; support allowlist patterns if present (e.g., .gitleaks.toml).
            2) Detect risky workflow patterns: unpinned actions, overbroad permissions, unsafe pull_request_target usage, secrets in forked PR contexts, deprecated insecure commands, missing permissions blocks.
            3) Maintain a persistent branch for this run using the Hardening Branch Prefix from Context. Create it if missing, update it otherwise, and push changes to origin.
            4) Propose minimal edits: redact literals where safe, add ignore rules, pin actions to SHA, reduce permissions, add guardrails to workflows, and add a SECURITY_LOG.md summarizing changes and remediation guidance.
            5) Push to origin.
            6) If there is at least one open PR in the repo, post or update a single natural-language comment (1–2 sentences) on the most recently updated open PR that briefly explains the hardening changes and includes an inline compare link to quick-create a PR.
            7) Avoid duplicate comments; update an existing bot comment if present. If no changes or no open PRs, post nothing.

            # Inputs and conventions:
            - Use `gh` to list PRs and to post comments. Avoid duplicate comments.

            # Deliverables when updates occur:
             - Pushed commits to the persistent hardening branch for this run.
            - A single natural-language PR comment with the compare link above (only if an open PR exists).
            " --force --model "$MODEL" --output-format=text

  ```
</CodeGroup>



# 키 번역
Source: https://docs.cursor.com/ko/cli/cookbook/translate-keys

GitHub Actions에서 Cursor CLI로 리포지토리의 번역 키를 관리

Cursor CLI로 국제화(i18n) 번역 키를 관리해. 이 워크플로는 PR에서 새로 추가되거나 변경된 i18n 키를 감지하고, 기존 번역을 덮어쓰지 않고 누락된 번역만 채워줘.

<CodeGroup>
  ```yaml auto-translate-keys.yml theme={null}
  name: Translate Keys

  on:
    pull_request:
      types: [opened, synchronize, reopened, ready_for_review]

  permissions:
    contents: write
    pull-requests: write

  jobs:
    i18n:
      if: ${{ !startsWith(github.head_ref, 'translate/') }}
      runs-on: ubuntu-latest
      steps:
        - name: Checkout repository
          uses: actions/checkout@v4
          with:
            fetch-depth: 0

        - name: Install Cursor CLI
          run: |
            curl https://cursor.com/install -fsS | bash
            echo "$HOME/.cursor/bin" >> $GITHUB_PATH

        - name: Configure git identity
          run: |
            git config user.name "Cursor Agent"
            git config user.email "cursoragent@cursor.com"

        - name: Propose i18n updates
          env:
            CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
            MODEL: gpt-5
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            BRANCH_PREFIX: translate
          run: |
            cursor-agent -p "You are operating in a GitHub Actions runner.

            The GitHub CLI is available as `gh` and authenticated via `GH_TOKEN`. Git is available. You have write access to repository contents and can comment on pull requests, but you must not create or edit PRs directly.

            # Context:
            - Repo: ${{ github.repository }}
            - PR Number: ${{ github.event.pull_request.number }}
            - Head Ref: ${{ github.head_ref }}
            - Translate Branch Prefix: ${{ env.BRANCH_PREFIX }}

            # Goal:
            - Detect i18n keys added or changed in the PR and fill only missing locales in message files. Never overwrite existing translations.

            # Requirements:
            1) Determine changed keys by inspecting the PR diff (source files and messages files).
            2) Compute missing keys per locale using the source/canonical locale as truth.
            3) Add entries only for missing keys. Preserve all existing values untouched.
            4) Validate JSON formatting and schemas.
            5) Maintain a persistent translate branch for this PR head using the Translate Branch Prefix from Context. Create it if missing, update it otherwise, and push changes to origin.
            6) Post or update a single PR comment on the original PR written in natural language (1–2 sentences) that briefly explains what was updated and why, and includes an inline compare link to quick-create a PR.
            7) Avoid duplicate comments; update a previous bot comment if present.
            8) If no changes are necessary, make no commits and post no comment.

            # Inputs and conventions:
            - Use `gh pr diff` and git history to detect changes.

            # Deliverables when updates occur:
            - Pushed commits to the persistent translate branch for this PR head.
            - A single natural-language PR comment on the original PR with the compare link above.
            " --force --model "$MODEL" --output-format=text

  ```
</CodeGroup>



# 문서 업데이트
Source: https://docs.cursor.com/ko/cli/cookbook/update-docs

GitHub Actions에서 Cursor CLI로 리포지토리 문서를 업데이트

GitHub Actions에서 Cursor CLI로 문서를 업데이트해. 방법은 두 가지: 에이전트의 완전 자율 실행, 또는 에이전트만 파일을 수정하는 결정적 워크플로우.

<CodeGroup>
  ```yaml auto-update-docs.yml theme={null}
  name: 문서 업데이트

  on:
    pull_request:
      types: [opened, synchronize, reopened, ready_for_review]

  permissions:
    contents: write
    pull-requests: write

  jobs:
    auto-docs:
      if: ${{ !startsWith(github.head_ref, 'docs/') }}
      runs-on: ubuntu-latest
      steps:
        - name: 리포지토리 체크아웃
          uses: actions/checkout@v4
          with:
            fetch-depth: 0

        - name: Cursor CLI 설치
          run: |
            curl https://cursor.com/install -fsS | bash
            echo "$HOME/.cursor/bin" >> $GITHUB_PATH

        - name: git 설정
          run: |
            git config user.name "Cursor Agent"
            git config user.email "cursoragent@cursor.com"

        - name: 문서 업데이트
          env:
            MODEL: gpt-5
            CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            BRANCH_PREFIX: docs
          run: |
            cursor-agent -p "넌 GitHub Actions 러너에서 동작하고 있어.

            GitHub CLI는 `gh`로 사용할 수 있고 `GH_TOKEN`으로 인증되어 있어. Git도 사용 가능해. 리포지토리 콘텐츠에 쓸 수 있고 풀 리퀘스트에 댓글을 남길 수 있지만, PR을 생성하거나 수정하면 안 돼.

            # 컨텍스트:
            - Repo: ${{ github.repository }}
            - Owner: ${{ github.repository_owner }}
            - PR Number: ${{ github.event.pull_request.number }}
            - Base Ref: ${{ github.base_ref }}
            - Head Ref: ${{ github.head_ref }}
            - Docs Branch Prefix: ${{ env.BRANCH_PREFIX }}

            # 목표:
            - 원본 PR의 점진적 변경에 따라 동작하는 엔드투엔드 문서 업데이트 플로우를 구현해.

            # 요구 사항:
            1) 원본 PR에서 무엇이 변경됐는지 파악하고, 여러 번 푸시가 있었다면 마지막으로 문서가 성공적으로 업데이트된 이후부터의 증분(diff)을 계산해.
            2) 그 증분 변경에 기반해 관련 문서만 업데이트해.
            3) 컨텍스트의 문서 브랜치 접두사를 사용해 이 PR 헤드에 대한 지속적인 문서 브랜치를 유지해. 없으면 생성하고, 있으면 업데이트해, 그리고 변경 사항을 origin에 푸시해.
            4) PR을 생성할 권한은 없어. 대신 문서 업데이트를 간단히 설명하고 PR을 빠르게 생성할 수 있는 인라인 비교 링크를 포함한 자연어 PR 댓글을 하나(1–2문장) 게시하거나 업데이트해.

            # 입력 및 규칙:
            - 변경 사항을 감지하고 마지막 문서 업데이트 이후의 증분 범위를 도출하기 위해 `gh pr diff`와 git 히스토리를 사용해.
            - PR을 직접 생성하거나 수정하려고 하지 마. 위의 비교 링크 형식을 사용해.
            - 변경은 최소화하고 리포 스타일과 일치시켜. 문서 업데이트가 필요 없으면 아무 변경도 하지 말고 댓글도 달지 마.

            # 업데이트 시 산출물:
            - 이 PR 헤드에 대한 지속적인 문서 브랜치로 푸시된 커밋.
            - 원본 PR에 위의 인라인 비교 링크를 포함한 자연어 PR 댓글 한 개. 중복 게시를 피하고, 이전 봇 댓글이 있으면 업데이트해.
            " --force --model "$MODEL" --output-format=text
  ```

  ```yaml auto-update-docs-deterministic.yml theme={null}
  name: 문서 업데이트

  on:
    pull_request:
      types: [opened, synchronize, reopened, ready_for_review]

  permissions:
    contents: write
    pull-requests: write

  jobs:
    auto-docs:
      if: ${{ !startsWith(github.head_ref, 'docs/') }}
      runs-on: ubuntu-latest
      steps:
        - name: 리포지토리 체크아웃
          uses: actions/checkout@v4
          with:
            fetch-depth: 0

        - name: Cursor CLI 설치
          run: |
            curl https://cursor.com/install -fsS | bash
            echo "$HOME/.cursor/bin" >> $GITHUB_PATH

        - name: git 구성
          run: |
            git config user.name "Cursor Agent"
            git config user.email "cursoragent@cursor.com"

        - name: 문서 업데이트 생성(커밋/푸시/댓글 없음)
          env:
            MODEL: gpt-5
            CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            BRANCH_PREFIX: docs
          run: |
            cursor-agent -p "너는 GitHub Actions 러너에서 동작하고 있어.

            GitHub CLI는 `gh`로 사용할 수 있고 `GH_TOKEN`으로 인증돼 있어. Git도 사용 가능해.

            중요: 브랜치 생성, 커밋, 푸시, PR 댓글 게시를 절대 하지 마. 필요한 경우에만 작업 디렉터리의 파일만 수정해. 이후 워크플로 단계가 변경 사항 게시와 PR 댓글 작성을 담당해.

            # 컨텍스트:
            - Repo: ${{ github.repository }}
            - Owner: ${{ github.repository_owner }}
            - PR Number: ${{ github.event.pull_request.number }}
            - Base Ref: ${{ github.base_ref }}
            - Head Ref: ${{ github.head_ref }}

            # 목표:
            - 이 PR이 도입한 증분 변경 사항을 기반으로 리포지토리 문서를 업데이트해.

            # 요구사항:
            1) 원래 PR에서 무엇이 변경됐는지 파악해(`gh pr diff`와 git 히스토리를 필요에 따라 사용). 기존의 지속 문서 브랜치 `${{ env.BRANCH_PREFIX }}/${{ github.head_ref }}`가 있다면, 이전 업데이트를 이해하기 위한 읽기 전용 기준점으로 사용할 수 있어.
            2) 해당 변경에 따라 관련 문서만 업데이트해. 편집은 최소화하고 리포 스타일과 일관되게 유지해.
            3) 커밋, 푸시, 브랜치 생성, PR 댓글 게시를 하지 마. 작업 트리는 업데이트된 파일만 남겨두고, 게시 작업은 이후 단계가 수행해.

            # 입력 및 규칙:
            - 변경 사항을 감지하고 그에 맞춰 문서 편집에 집중하기 위해 `gh pr diff`와 git 히스토리를 사용해.
            - 문서 업데이트가 필요 없다면 변경하지 말고 어떤 출력도 생성하지 마.

            # 업데이트 발생 시 산출물:
            - 작업 디렉터리에만 존재하는 수정된 문서 파일(커밋/푸시/댓글 없음).
            " --force --model "$MODEL" --output-format=text

        - name: 문서 브랜치 게시
          id: publish_docs
          env:
            BRANCH_PREFIX: docs
            HEAD_REF: ${{ github.head_ref }}
            PR_NUMBER: ${{ github.event.pull_request.number }}
          run: |
            echo "changes_published=false" >> "$GITHUB_OUTPUT"

            DOCS_BRANCH="${BRANCH_PREFIX}/${HEAD_REF}"

            # Ensure we are on a local branch that we can push
            git fetch origin --prune

            # 푸시 가능한 로컬 브랜치에 있는지 확인
            git checkout -B "$DOCS_BRANCH"
            # 현재 작업 트리 변경 사항을 유지한 채 지속 문서 브랜치 생성/전환
            # 변경 사항 스테이징 및 감지
            git add -A
            if git diff --staged --quiet; then
              echo "게시할 문서 변경 사항이 없습니다. 커밋/푸시는 건너뜁니다."
              exit 0
            fi

            COMMIT_MSG="docs: update for PR #${PR_NUMBER} (${HEAD_REF} @ $(git rev-parse --short HEAD))"
            git commit -m "$COMMIT_MSG"
            git push --set-upstream origin "$DOCS_BRANCH"

            echo "changes_published=true" >> "$GITHUB_OUTPUT"

        - name: PR 댓글 게시 또는 업데이트
          if: steps.publish_docs.outputs.changes_published == 'true'
          env:
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            BRANCH_PREFIX: docs
            REPO: ${{ github.repository }}
            BASE_REF: ${{ github.base_ref }}
            HEAD_REF: ${{ github.head_ref }}
            PR_NUMBER: ${{ github.event.pull_request.number }}
          run: |

            DOCS_BRANCH="${BRANCH_PREFIX}/${HEAD_REF}"
            COMPARE_URL="https://github.com/${REPO}/compare/${BASE_REF}...${DOCS_BRANCH}?quick_pull=1&title=docs%3A+updates+for+PR+%23${PR_NUMBER}"

            COMMENT_FILE="${RUNNER_TEMP}/auto-docs-comment.md"
            {
              echo "Cursor가 문서 브랜치를 업데이트했어: \`${DOCS_BRANCH}\`"
              echo "이제 [diff를 확인하고 이 문서 업데이트를 병합하기 위한 PR을 빠르게 생성](${COMPARE_URL})할 수 있어."
              echo
              echo "_이 댓글은 PR 변경에 따라 이후 실행에서 업데이트돼._"
              echo
              echo "<!-- auto-update-docs-split -->"
            } > "$COMMENT_FILE"

            # 마지막 봇 댓글 편집이 실패하면(구버전 gh) 새 댓글 생성으로 대체
            if gh pr comment "$PR_NUMBER" --body-file "$COMMENT_FILE" --edit-last; then
              echo "기존 PR 댓글을 업데이트했어."
            else
              gh pr comment "$PR_NUMBER" --body-file "$COMMENT_FILE"
              echo "새 PR 댓글을 게시했어."
            fi
  ```
</CodeGroup>



# GitHub Actions
Source: https://docs.cursor.com/ko/cli/github-actions

GitHub Actions 및 기타 지속적 통합 시스템에서 Cursor CLI를 사용하는 방법을 알아보자

GitHub Actions 및 기타 CI/CD 시스템에서 Cursor CLI를 사용해 개발 작업을 자동화하자.

<div id="github-actions-integration">
  ## GitHub Actions 통합
</div>

기본 구성:

```yaml  theme={null}
- name: Cursor CLI 설치
  run: |
    curl https://cursor.com/install -fsS | bash
    echo "$HOME/.cursor/bin" >> $GITHUB_PATH

- name: Cursor Agent 실행
  env:
    CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
  run: |
    cursor-agent -p "여기에 프롬프트를 입력해" --model gpt-5
```

<div id="cookbook-examples">
  ## 쿠크북 예시
</div>

실무 워크플로에 도움이 되는 쿠크북 예시를 확인해봐: [문서 업데이트](/ko/cli/cookbook/update-docs)와 [CI 문제 해결](/ko/cli/cookbook/fix-ci).

<div id="other-ci-systems">
  ## 기타 CI 시스템
</div>

다음이 갖춰진 어떤 CI/CD 시스템에서도 Cursor CLI를 사용할 수 있어:

* **셸 스크립트 실행**(bash, zsh 등)
* API 키 구성을 위한 **환경 변수**
* Cursor API에 접근할 **인터넷 연결**

<div id="autonomy-levels">
  ## 자율성 수준
</div>

에이전트의 자율성 수준을 선택해:

<div id="full-autonomy-approach">
  ### 완전 자율 방식
</div>

에이전트가 git 작업, API 호출, 외부 상호작용을 모두 직접 제어하게 해. 설정은 더 간단하지만, 더 큰 신뢰가 필요해.

**예시:** 우리 [Update Documentation](/ko/cli/cookbook/update-docs) 쿠크북의 첫 번째 워크플로우에선 에이전트가 다음을 수행해:

* PR 변경 사항 분석
* git 브랜치 생성 및 관리
* 변경 사항 커밋 및 푸시
* 풀 리퀘스트에 댓글 작성
* 모든 오류 시나리오 처리

```yaml  theme={null}
- name: 문서 업데이트 (완전 자율)
  run: |
    cursor-agent -p "git, GitHub CLI, 그리고 PR 작업에 완전한 접근 권한이 있어.
    커밋, 푸시, 그리고 PR 댓글을 포함해 전체 문서 업데이트 워크플로우를 처리해."
```

<div id="restricted-autonomy-approach">
  ### 제한적 자율성 접근 방식
</div>

<Note>
  프로덕션 CI 워크플로에선 **권한 기반 제한**과 함께 이 접근 방식을 쓰는 걸 추천해. 이렇게 하면 두 가지 장점을 모두 챙길 수 있어: 에이전트가 복잡한 분석과 파일 수정을 똑똑하게 처리하면서도, 중요한 작업은 결정론적이고 감사 가능하게 유지돼.
</Note>

중요 단계를 별도의 워크플로 단계로 분리하면서 에이전트의 작업 범위를 제한해. 제어와 예측 가능성이 더 좋아져.

**예시:** 같은 쿠크북의 두 번째 워크플로는 에이전트를 파일 수정으로만 제한해:

```yaml  theme={null}
- name: 문서 업데이트 생성 (제한됨)
  run: |
    cursor-agent -p "중요: 브랜치 생성, 커밋, 푸시, PR 댓글 작성 금지.
    작업 디렉터리의 파일만 수정해. 게시 작업은 이후 워크플로 단계에서 처리돼."

- name: 문서 브랜치 게시 (결정적)
  run: |
    # CI에서 결정적 git 작업을 처리함
    git checkout -B "docs/${{ github.head_ref }}"
    git add -A
    git commit -m "docs: PR 업데이트"
    git push origin "docs/${{ github.head_ref }}"

- name: PR 댓글 게시 (결정적)  
  run: |
    # CI에서 결정적 PR 댓글 작성을 처리함
    gh pr comment ${{ github.event.pull_request.number }} --body "문서가 업데이트됨"
```

<div id="permission-based-restrictions">
  ### 권한 기반 제한
</div>

CLI 수준에서 제한을 적용하려면 [권한 구성](/ko/cli/reference/permissions)을 사용해.

```json  theme={null}
{
  "permissions": {
    "allow": [
      "Read(**/*.md)",
      "Write(docs/**/*)",
      "Shell(grep)",
      "Shell(find)"
    ],
    "deny": [
      "Shell(git)",
      "Shell(gh)", 
      "Write(.env*)",
      "Write(package.json)"
    ]
  }
}
```

<div id="authentication">
  ## 인증
</div>

<div id="generate-your-api-key">
  ### API 키 생성
</div>

먼저 Cursor 대시보드에서 [API 키를 생성](/ko/cli/reference/authentication#api-key-authentication)해.

<div id="configure-repository-secrets">
  ### 리포지토리 시크릿 설정
</div>

리포지토리에 Cursor API 키를 안전하게 저장해:

1. GitHub 리포지토리로 이동해
2. **Settings** → **Secrets and variables** → **Actions**를 클릭해
3. **New repository secret**을 클릭해
4. 이름을 `CURSOR_API_KEY`로 지정해
5. 값으로 API 키를 붙여 넣어
6. **Add secret**을 클릭해

<div id="use-in-workflows">
  ### 워크플로에서 사용
</div>

`CURSOR_API_KEY` 환경 변수를 설정해:

```yaml  theme={null}
env:
  CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
```



# Headless CLI 사용하기
Source: https://docs.cursor.com/ko/cli/headless

자동 코드 분석, 생성, 수정 작업을 위해 Cursor CLI로 스크립트를 작성하는 방법을 알아봐

스크립트와 자동화 워크플로에서 Cursor CLI를 사용해 코드 분석, 생성, 리팩터링 작업을 수행해봐.

<div id="how-it-works">
  ## 작동 방식
</div>

비대화형 스크립팅과 자동화를 위해 [print 모드](/ko/cli/using#non-interactive-mode) (`-p, --print`)를 사용해.

<div id="file-modification-in-scripts">
  ### 스크립트에서 파일 수정
</div>

스크립트에서 파일을 수정하려면 `--print`와 `--force`를 함께 써:

```bash  theme={null}

# 프린트 모드에서 파일 수정 활성화
cursor-agent -p --force "Refactor this code to use modern ES6+ syntax"


# --force가 없으면 변경 사항은 제안만 되고 적용되지는 않아
cursor-agent -p "이 파일에 JSDoc 주석을 추가해 줘"  # 파일은 수정하지 않아


# 실제 파일 수정을 포함한 배치 처리
find src/ -name "*.js" | while read file; do
  cursor-agent -p --force "$file에 포괄적인 JSDoc 주석을 추가해 줘"
done
```

<Warning>
  `--force` 플래그를 사용하면 에이전트가 확인 없이 파일을 직접 변경할 수 있어
</Warning>

<div id="setup">
  ## 설정
</div>

전체 설정 방법은 [설치](/ko/cli/installation)와 [인증](/ko/cli/reference/authentication) 문서를 참고해.

```bash  theme={null}

# Cursor CLI 설치
curl https://cursor.com/install -fsS | bash


# 스크립트용 API 키 설정  
export CURSOR_API_KEY=your_api_key_here
cursor-agent -p "이 코드를 분석해 줘"
```

<div id="example-scripts">
  ## 예시 스크립트
</div>

스크립트 목적에 맞게 출력 형식을 다르게 써. 자세한 내용은 [Output format](/ko/cli/reference/output-format)을 참고해.

<div id="searching-the-codebase">
  ### 코드베이스 검색
</div>

읽기 쉬운 응답이 필요하면 `--output-format text`를 써:

```bash  theme={null}
#!/bin/bash

# 간단한 코드베이스 질문

cursor-agent -p --output-format text "이 코드베이스는 무엇을 하나?"
```

<div id="automated-code-review">
  ### 자동 코드 리뷰
</div>

구조화된 분석에는 `--output-format json`을 사용해:

```bash  theme={null}
#!/bin/bash

# simple-code-review.sh - 기본 코드 리뷰 스크립트

echo "코드 리뷰를 시작하는 중..."


# 최근 변경사항 리뷰
cursor-agent -p --force --output-format text \
  "최근 코드 변경사항을 검토하고 다음 항목에 대해 피드백을 제공해줘:
  - 코드 품질과 가독성  
  - 잠재적 버그 또는 이슈
  - 보안 고려 사항
  - 모범 사례 준수 여부

  개선을 위한 구체적인 제안을 제시하고 review.txt에 작성해줘"

if [ $? -eq 0 ]; then
  echo "✅ 코드 리뷰를 성공적으로 완료"
else
  echo "❌ 코드 리뷰 실패"
  exit 1
fi
```

<div id="real-time-progress-tracking">
  ### 실시간 진행 상황 추적
</div>

실시간 진행 상황을 추적하려면 `--output-format stream-json`을(를) 사용해:

```bash  theme={null}
#!/bin/bash

# stream-progress.sh - 실시간 진행 상황 추적

echo "🚀 스트림 처리 시작..."


# 실시간 진행 상황 추적
accumulated_text=""
tool_count=0
start_time=$(date +%s)

cursor-agent -p --force --output-format stream-json \
  "이 프로젝트 구조를 분석하고 analysis.txt에 요약 보고서를 만들어줘" | \
  while IFS= read -r line; do
    
    type=$(echo "$line" | jq -r '.type // empty')
    subtype=$(echo "$line" | jq -r '.subtype // empty')
    
    case "$type" in
      "system")
        if [ "$subtype" = "init" ]; then
          model=$(echo "$line" | jq -r '.model // "unknown"')
          echo "🤖 사용 모델: $model"
        fi
        ;;
        
      "assistant")
        # 스트리밍 텍스트 델타 누적
        content=$(echo "$line" | jq -r '.message.content[0].text // empty')
        accumulated_text="$accumulated_text$content"
        
        # 실시간 진행 상황 표시
        printf "\r📝 생성 중: %d자" ${#accumulated_text}
        ;;
        
      "tool_call")
        if [ "$subtype" = "started" ]; then
          tool_count=$((tool_count + 1))
          
          # 도구 정보 추출
          if echo "$line" | jq -e '.tool_call.writeToolCall' > /dev/null 2>&1; then
            path=$(echo "$line" | jq -r '.tool_call.writeToolCall.args.path // "unknown"')
            echo -e "\n🔧 도구 #$tool_count: $path 생성"
          elif echo "$line" | jq -e '.tool_call.readToolCall' > /dev/null 2>&1; then
            path=$(echo "$line" | jq -r '.tool_call.readToolCall.args.path // "unknown"')
            echo -e "\n📖 도구 #$tool_count: $path 읽는 중"
          fi
          
        elif [ "$subtype" = "completed" ]; then
          # 도구 결과 추출 및 표시
          if echo "$line" | jq -e '.tool_call.writeToolCall.result.success' > /dev/null 2>&1; then
            lines=$(echo "$line" | jq -r '.tool_call.writeToolCall.result.success.linesCreated // 0')
            size=$(echo "$line" | jq -r '.tool_call.writeToolCall.result.success.fileSize // 0')
            echo "   ✅ $lines줄 생성됨 ($size바이트)"
          elif echo "$line" | jq -e '.tool_call.readToolCall.result.success' > /dev/null 2>&1; then
            lines=$(echo "$line" | jq -r '.tool_call.readToolCall.result.success.totalLines // 0')
            echo "   ✅ $lines줄 읽음"
          fi
        fi
        ;;
        
      "result")
        duration=$(echo "$line" | jq -r '.duration_ms // 0')
        end_time=$(date +%s)
        total_time=$((end_time - start_time))
        
        echo -e "\n\n🎯 완료: ${duration}ms 소요 (${total_time}s 총"
        echo "📊 최종 통계: 도구 $tool_count개, 총 ${#accumulated_text}자 생성"
        ;;
    esac
  done
```



# 설치
Source: https://docs.cursor.com/ko/cli/installation

Cursor CLI 설치 및 업데이트

<div id="installation">
  ## 설치
</div>

<div id="macos-linux-and-windows-wsl">
  ### macOS, Linux, Windows (WSL)
</div>

한 줄 명령으로 Cursor CLI 설치하기:

```bash  theme={null}
curl https://cursor.com/install -fsS | bash
```

<div id="verification">
  ### 확인
</div>

설치 후 Cursor CLI가 제대로 동작하는지 확인해봐:

```bash  theme={null}
cursor-agent --version
```

<div id="post-installation-setup">
  ## 설치 후 설정
</div>

1. **\~/.local/bin을 PATH에 추가하기:**

   bash:

   ```bash  theme={null}
   echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
   source ~/.bashrc
   ```

   zsh:

   ```bash  theme={null}
   echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc
   source ~/.zshrc
   ```

2. **Cursor Agent 시작하기:**
   ```bash  theme={null}
   cursor-agent
   ```

<div id="updates">
  ## 업데이트
</div>

Cursor CLI는 기본적으로 자동으로 업데이트돼서 항상 최신 버전을 쓸 수 있어.

Cursor CLI를 수동으로 최신 버전으로 업데이트하려면:

```bash  theme={null}
cursor-agent update

# 또는 
cursor-agent upgrade
```

두 명령 모두 Cursor Agent를 최신 버전으로 업데이트해줄 거야.



# MCP
Source: https://docs.cursor.com/ko/cli/mcp

cursor-agent와 함께 MCP 서버를 사용해 외부 도구와 데이터 소스에 연결

export const Kbd = ({children, tooltip, os}) => {
  const keysInput = typeof children === 'string' && children.trim() !== '' ? children : null;
  if (!keysInput) {
    return null;
  }
  const isModifier = key => {
    const modifiers = ['⌘', '⇧', '⌥', '⌃', '⏎', '⌫', '⌦', '⎋', '⇥', '⌁', '←', '→', '↑', '↓', 'Ctrl', 'Shift', 'Alt', 'Cmd', 'Opt', 'Return', 'Backspace', 'Delete', 'Escape', 'Tab', 'Space', 'Enter', 'Esc', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down'];
    return modifiers.includes(key.trim());
  };
  const capitalizeFirstLetter = string => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  const isMac = os ? os.toLowerCase() === 'mac' || os.toLowerCase() === 'macos' : typeof navigator !== 'undefined' && (navigator.platform.toUpperCase().indexOf('MAC') >= 0 || navigator.userAgent.toUpperCase().indexOf('MAC') >= 0);
  const convertToSymbols = shortcut => {
    if (isMac) {
      return shortcut.replace(/⌘|Cmd|CMD/gi, '⌘').replace(/⌥|Opt|OPT/gi, '⌥').replace(/⌃|Ctrl/gi, '⌃').replace(/⇧|Shift/gi, '⇧').replace(/⏎|Return/gi, '⏎').replace(/⌫|Backspace/gi, '⌫').replace(/⌦|Delete/gi, '⌦').replace(/␛|Escape/gi, '␛').replace(/⇥|Tab/gi, '⇥').replace(/⌁|Space/gi, '⌁').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, '←').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, '→').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, '↑').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, '↓');
    } else {
      const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Ctrl').replace(/⌥|Opt|OPT/gi, 'Alt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Enter').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Esc').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
      const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
      return keyList.join('+');
    }
  };
  const convertToReadableText = shortcut => {
    const converted = shortcut.replace(/⌘|Cmd|CMD/gi, 'Cmd').replace(/⌥|Opt|OPT/gi, 'Opt').replace(/⌃|Ctrl/gi, 'Ctrl').replace(/⇧|Shift/gi, 'Shift').replace(/⏎|Return/gi, 'Return').replace(/⌫|Backspace/gi, 'Backspace').replace(/⌦|Delete/gi, 'Delete').replace(/⎋|Escape/gi, 'Escape').replace(/⇥|Tab/gi, 'Tab').replace(/⌁|Space/gi, 'Space').replace(/←|Arrow\s*Left|ArrowLeft|Left/gi, 'Arrow-Left').replace(/→|Arrow\s*Right|ArrowRight|Right/gi, 'Arrow-Right').replace(/↑|Arrow\s*Up|ArrowUp|Up/gi, 'Arrow-Up').replace(/↓|Arrow\s*Down|ArrowDown|Down/gi, 'Arrow-Down');
    const keyList = converted.split(/[\+\s]+/).filter(key => key.trim());
    return keyList.map(key => {
      const trimmedKey = key.trim();
      return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
    }).join('+');
  };
  const displayShortcut = convertToSymbols(keysInput);
  const tooltipText = isMac ? tooltip ? `${convertToReadableText(keysInput)}: ${tooltip}` : convertToReadableText(keysInput) : tooltip || null;
  const processedKeys = isMac ? displayShortcut.split(/[\+\s]+/).filter(key => key.trim()).map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('') : displayShortcut.split('+').map(key => {
    const trimmedKey = key.trim();
    return isModifier(trimmedKey) ? trimmedKey : capitalizeFirstLetter(trimmedKey);
  }).join('+');
  return tooltipText ? <Tooltip tip={tooltipText}>
      <kbd>
        {processedKeys}
      </kbd>
    </Tooltip> : <kbd>
      {processedKeys}
    </kbd>;
};

<div id="overview">
  ## 개요
</div>

Cursor CLI는 [Model Context Protocol(MCP)](/ko/context/mcp) 서버를 지원해서 외부 도구와 데이터 소스를 `cursor-agent`에 연결할 수 있어. **CLI에서 MCP는 에디터와 동일한 설정을 써**—설정해 둔 MCP 서버는 둘 다에서 매끄럽게 그대로 동작해.

<Card title="MCP 알아보기" icon="link" href="/ko/context/mcp">
  MCP가 처음이야? 구성, 인증, 사용 가능한 서버에 대한 전체 가이드를 읽어봐
</Card>

<div id="cli-commands">
  ## CLI 명령어
</div>

`cursor-agent mcp` 명령어로 MCP 서버를 관리해:

<div id="list-configured-servers">
  ### 구성된 서버 목록
</div>

구성된 모든 MCP 서버와 현재 상태를 확인해:

```bash  theme={null}
cursor-agent mcp list
```

다음이 표시돼:

* 서버 이름과 식별자
* 연결 상태(연결됨/연결 끊김)
* 구성 소스(프로젝트 또는 전역)
* 전송 방식(stdio, HTTP, SSE)

<div id="list-available-tools">
  ### 사용 가능한 도구 목록
</div>

특정 MCP 서버에서 제공하는 도구 보기:

```bash  theme={null}
cursor-agent mcp list-tools <identifier>
```

이건 다음을 보여줘:

* 도구 이름과 설명
* 필수 및 선택 매개변수
* 매개변수 타입과 제약 조건

<div id="login-to-mcp-server">
  ### MCP 서버에 로그인
</div>

`mcp.json`에 설정된 MCP 서버에 인증해:

```bash  theme={null}
cursor-agent mcp login <identifier>
```

<div id="disable-mcp-server">
  ### MCP 서버 비활성화
</div>

로컬 승인 목록에서 MCP 서버를 제거:

```bash  theme={null}
cursor-agent mcp disable <identifier>
```

<div id="using-mcp-with-agent">
  ## Agent와 함께 MCP 사용하기
</div>

MCP 서버를 구성한 뒤([메인 MCP 가이드](/ko/context/mcp) 참고), `cursor-agent`는 너의 요청과 관련 있을 때 사용 가능한 도구를 자동으로 찾아서 사용해.

```bash  theme={null}

# 사용 가능한 MCP 서버 확인
cursor-agent mcp list


# 특정 서버가 제공하는 도구 확인
cursor-agent mcp list-tools playwright


# cursor-agent 사용 - 필요할 때 MCP 도구를 자동으로 사용함
cursor-agent --prompt "google.com으로 이동해서 검색 페이지 스크린샷 찍기"
```

CLI는 에디터와 같은 구성 우선순위(프로젝트 → 전역 → 중첩)를 따르고, 상위 디렉터리에서 구성을 자동으로 찾아.

<div id="related">
  ## 관련
</div>

<CardGroup cols={2}>
  <Card title="MCP 개요" icon="link" href="/ko/context/mcp">
    MCP 종합 가이드: 설정, 구성, 인증
  </Card>

  <Card title="사용 가능한 MCP 도구" icon="table" href="/ko/tools">
    바로 쓸 수 있는 사전 구축된 MCP 서버 살펴보기
  </Card>
</CardGroup>



# Cursor CLI
Source: https://docs.cursor.com/ko/cli/overview

터미널에서 Cursor CLI로 코딩을 시작해 봐

Cursor CLI는 터미널에서 바로 AI 에이전트와 상호작용해 코드를 작성하고, 리뷰하고, 수정할 수 있게 해줘. 대화형 터미널 인터페이스를 쓰든 스크립트와 CI 파이프라인을 위한 출력 자동화를 원하든, CLI는 네가 일하는 그 자리에서 강력한 코딩 지원을 제공해.

```bash  theme={null}

# 설치
curl https://cursor.com/install -fsS | bash


# 대화형 세션 시작
cursor-agent
```

<Frame>
  <video src="https://mintcdn.com/cursor/BfJOqJ1Wb8EvuXyr/images/cli/cli-overview.mp4?fit=max&auto=format&n=BfJOqJ1Wb8EvuXyr&q=85&s=b323547dd61e985df8c0d6179c1492bd" autoPlay loop muted playsInline controls data-path="images/cli/cli-overview.mp4" />
</Frame>

<Info>
  Cursor CLI는 지금 베타야. 피드백 들려줘!
</Info>

<div id="interactive-mode">
  ### 인터랙티브 모드
</div>

에이전트와 대화형 세션을 시작해서 목표를 설명하고, 제안된 변경 사항을 검토하고, 명령을 승인해줘:

```bash  theme={null}

# 대화형 세션 시작
cursor-agent


# 초기 프롬프트 실행
cursor-agent "auth 모듈을 JWT 토큰을 쓰도록 리팩터해줘"
```

<div id="non-interactive-mode">
  ### 비대화형 모드
</div>

스크립트, CI 파이프라인, 자동화처럼 대화형이 아닌 시나리오에서는 print 모드를 써:

```bash  theme={null}

# 지정한 프롬프트와 모델로 실행
cursor-agent -p "성능 문제를 찾아서 고쳐줘" --model "gpt-5"


# 검토용으로 git 변경 사항 포함해 사용
cursor-agent -p "이 변경 사항에서 보안 이슈를 검토해줘" --output-format text
```

<div id="sessions">
  ### 세션
</div>

이전 대화를 이어서 컨텍스트를 여러 번의 상호작용에서도 유지해:

```bash  theme={null}

# 이전 채팅 모두 나열
cursor-agent ls


# 가장 최근 대화 이어서 진행
cursor-agent resume


# 특정 대화 이어서 진행
cursor-agent --resume="chat-id-here"
```



# 인증
Source: https://docs.cursor.com/ko/cli/reference/authentication

브라우저 플로우 또는 API 키로 Cursor CLI 인증하기

Cursor CLI는 두 가지 인증 방식을 지원해: 브라우저 기반 로그인(권장)과 API 키.

<div id="browser-authentication-recommended">
  ## 브라우저 인증(권장)
</div>

가장 간편한 인증을 위해 브라우저 플로우를 사용해봐:

```bash  theme={null}

# 브라우저 플로우로 로그인
cursor-agent login


# 인증 상태 확인
cursor-agent status


# 로그아웃하고 저장된 인증 정보 삭제
cursor-agent logout
```

login 명령을 실행하면 기본 브라우저가 열리고 Cursor 계정으로 로그인하라는 안내가 떠. 완료되면 자격 증명이 로컬에 안전하게 저장돼.

<div id="api-key-authentication">
  ## API 키 인증
</div>

자동화, 스크립트, CI/CD 환경에서는 API 키 인증을 써:

<div id="step-1-generate-an-api-key">
  ### 1단계: API 키 생성
</div>

Cursor 대시보드의 Integrations > User API Keys에서 API 키를 만들어.

<div id="step-2-set-the-api-key">
  ### 2단계: API 키 설정
</div>

API 키는 두 가지 방식으로 전달할 수 있어:

**옵션 1: 환경 변수(권장)**

```bash  theme={null}
export CURSOR_API_KEY=your_api_key_here
cursor-agent "사용자 인증 구현"
```

**옵션 2: 커맨드라인 플래그**

```bash  theme={null}
cursor-agent --api-key your_api_key_here "사용자 인증을 구현해줘"
```

<div id="authentication-status">
  ## 인증 상태
</div>

현재 인증 상태를 확인해봐:

```bash  theme={null}
cursor-agent status
```

이 명령은 다음을 보여줘:

* 인증되어 있는지 여부
* 계정 정보
* 현재 엔드포인트 설정

<div id="troubleshooting">
  ## 문제 해결
</div>

* **"Not authenticated" 오류:** `cursor-agent login`을 실행하거나 API 키가 제대로 설정됐는지 확인해
* **SSL 인증서 오류:** 개발 환경에서는 `--insecure` 플래그를 사용해
* **엔드포인트 문제:** 커스텀 API 엔드포인트를 지정하려면 `--endpoint` 플래그를 사용해



# Configuration
Source: https://docs.cursor.com/ko/cli/reference/configuration

cli-config.json용 Agent CLI 구성 레퍼런스

`cli-config.json` 파일로 Agent CLI를 구성해.

<div id="file-location">
  ## 파일 위치
</div>

<div class="full-width-table">
  | 유형   | 플랫폼         | 경로                                         |
  | :--- | :---------- | :----------------------------------------- |
  | 전역   | macOS/Linux | `~/.cursor/cli-config.json`                |
  | 전역   | Windows     | `$env:USERPROFILE\.cursor\cli-config.json` |
  | 프로젝트 | 전체          | `<project>/.cursor/cli.json`               |
</div>

<Note>프로젝트 수준에서는 권한만 설정할 수 있어. 나머지 CLI 설정은 전부 전역으로 설정해야 해.</Note>

환경 변수로 오버라이드:

* **`CURSOR_CONFIG_DIR`**: 커스텀 디렉터리 경로
* **`XDG_CONFIG_HOME`** (Linux/BSD): `$XDG_CONFIG_HOME/cursor/cli-config.json` 사용

<div id="schema">
  ## 스키마
</div>

<div id="required-fields">
  ### 필수 필드
</div>

<div class="full-width-table">
  | Field               | Type      | Description                                                   |
  | :------------------ | :-------- | :------------------------------------------------------------ |
  | `version`           | number    | 구성 스키마 버전(현재: `1`)                                            |
  | `editor.vimMode`    | boolean   | Vim 키바인딩 사용(기본값: `false`)                                     |
  | `permissions.allow` | string\[] | 허용되는 작업(자세한 내용: [Permissions](/ko/cli/reference/permissions)) |
  | `permissions.deny`  | string\[] | 금지되는 작업(자세한 내용: [Permissions](/ko/cli/reference/permissions)) |
</div>

<div id="optional-fields">
  ### 선택 필드
</div>

<div class="full-width-table">
  | Field                    | Type    | Description              |
  | :----------------------- | :------ | :----------------------- |
  | `model`                  | object  | 선택된 모델 설정                |
  | `hasChangedDefaultModel` | boolean | CLI에서 관리하는 기본 모델 재정의 플래그 |
</div>

<div id="examples">
  ## 예제
</div>

<div id="minimal-config">
  ### 최소 설정
</div>

```json  theme={null}
{
  "version": 1,
  "editor": { "vimMode": false },
  "permissions": { "allow": ["Shell(ls)"], "deny": [] }
}
```

<div id="enable-vim-mode">
  ### Vim 모드 켜기
</div>

```json  theme={null}
{
  "version": 1,
  "editor": { "vimMode": true },
  "permissions": { "allow": ["Shell(ls)"], "deny": [] }
}
```

<div id="configure-permissions">
  ### 권한 설정
</div>

```json  theme={null}
{
  "version": 1,
  "editor": { "vimMode": false },
  "permissions": {
    "allow": ["Shell(ls)", "Shell(echo)"],
    "deny": ["Shell(rm)"]
  }
}
```

사용 가능한 권한 유형과 예시는 [Permissions](/ko/cli/reference/permissions)에서 확인해.

<div id="troubleshooting">
  ## 문제 해결
</div>

**설정 오류**: 파일을 잠시 옮겨두고 다시 시작해.

```bash  theme={null}
mv ~/.cursor/cli-config.json ~/.cursor/cli-config.json.bad
```

**변경 사항이 유지되지 않음**: JSON이 유효한지, 쓰기 권한이 있는지 확인해. 일부 필드는 CLI에서 관리돼서 덮어쓰일 수 있어.

<div id="notes">
  ## 참고사항
</div>

* 순수 JSON 형식(주석 없음)
* CLI가 누락된 필드를 자동으로 복구함
* 손상된 파일은 `.bad`로 백업한 뒤 다시 생성됨
* 권한 항목은 정확한 문자열이어야 함(자세한 내용은 [Permissions](/ko/cli/reference/permissions) 참고)



# 출력 형식
Source: https://docs.cursor.com/ko/cli/reference/output-format

텍스트, JSON 및 stream-JSON 형식의 출력 스키마

Cursor Agent CLI는 `--print`와 함께 사용할 때 `--output-format` 옵션으로 여러 출력 형식을 제공해. 여기에는 프로그램에서 쓰기 위한 구조화된 형식(`json`, `stream-json`)과 사람이 읽기 쉬운 진행 상황 추적을 위한 단순화된 텍스트 형식이 포함돼.

<Note>
  기본 `--output-format`은 `stream-json`이야. 이 옵션은 출력할 때(`--print`)나 출력 모드가 추론되는 경우(비 TTY stdout 또는 파이프된 stdin)에서만 유효해.
</Note>

<div id="json-format">
  ## JSON 형식
</div>

`json` 출력 형식은 실행이 성공적으로 완료되면 하나의 JSON 객체(뒤이어 개행 문자)를 내보내. 델타와 도구 이벤트는 출력되지 않고, 텍스트는 최종 결과로 집계돼.

실패하면 프로세스는 0이 아닌 종료 코드로 종료되고, 오류 메시지를 stderr에 기록해. 실패한 경우에는 제대로 형성된 JSON 객체가 출력되지 않아.

<div id="success-response">
  ### 성공 응답
</div>

성공하면 CLI는 다음 구조의 JSON 객체를 출력해:

```json  theme={null}
{
  "type": "result",
  "subtype": "success",
  "is_error": false,
  "duration_ms": 1234,
  "duration_api_ms": 1234,
  "result": "<전체 assistant 텍스트>",
  "session_id": "<uuid>",
  "request_id": "<선택적 요청 ID>"
}
```

<div class="full-width-table">
  | Field             | Description                           |
  | ----------------- | ------------------------------------- |
  | `type`            | 터미널 결과의 경우 항상 `"result"`              |
  | `subtype`         | 성공적으로 완료된 경우 항상 `"success"`           |
  | `is_error`        | 성공적인 응답인 경우 항상 `false`                |
  | `duration_ms`     | 총 실행 시간(밀리초)                          |
  | `duration_api_ms` | API 요청 시간(밀리초) (현재 `duration_ms`와 동일) |
  | `result`          | 어시스턴트의 전체 응답 텍스트(모든 텍스트 델타를 연결한 값)    |
  | `session_id`      | 고유한 세션 식별자                            |
  | `request_id`      | 선택적 요청 식별자(생략될 수 있음)                  |
</div>

<div id="stream-json-format">
  ## 스트림 JSON 형식
</div>

`stream-json` 출력 형식은 줄바꿈으로 구분된 JSON(NDJSON)을 내보내. 각 줄엔 실행 중에 발생한 실시간 이벤트를 나타내는 단일 JSON 객체가 들어 있어.

스트림은 성공하면 마지막에 `result` 터미널 이벤트로 끝나. 실패하면 프로세스가 0이 아닌 코드로 종료되고, 터미널 이벤트 없이 스트림이 일찍 끝날 수도 있어. 오류 메시지는 stderr로 출력돼.

<div id="event-types">
  ### 이벤트 유형
</div>

<div id="system-initialization">
  #### 시스템 초기화
</div>

각 세션 시작 시 한 번 발생:

```json  theme={null}
{
  "type": "system",
  "subtype": "init",
  "apiKeySource": "env|flag|login",
  "cwd": "/absolute/path",
  "session_id": "<uuid>",
  "model": "<model display name>",
  "permissionMode": "default"
}
```

<Note>
  앞으로 이 이벤트에는 `tools`, `mcp_servers` 같은 필드가 추가될 수도 있어.
</Note>

<div id="user-message">
  #### 사용자 메시지
</div>

사용자가 입력한 프롬프트가 포함돼:

```json  theme={null}
{
  "type": "user",
  "message": {
    "role": "user",
    "content": [{ "type": "text", "text": "<prompt>" }]
  },
  "session_id": "<uuid>"
}
```

<div id="assistant-text-delta">
  #### 어시스턴트 텍스트 델타
</div>

어시스턴트가 응답을 생성하는 동안 여러 번 발생해. 이 이벤트에는 누적되는 텍스트 조각들이 포함돼:

```json  theme={null}
{
  "type": "assistant",
  "message": {
    "role": "assistant",
    "content": [{ "type": "text", "text": "<델타 청크>" }]
  },
  "session_id": "<uuid>"
}
```

<Note>
  전체 assistant 응답을 재구성하려면 순서대로 모든 `message.content[].text` 값을 이어 붙여.
</Note>

<div id="tool-call-events">
  #### 도구 호출 이벤트
</div>

도구 호출은 시작과 완료 이벤트로 추적돼:

**도구 호출 시작:**

```json  theme={null}
{
  "type": "tool_call",
  "subtype": "started",
  "call_id": "<string id>",
  "tool_call": {
    "readToolCall": {
      "args": { "path": "file.txt" }
    }
  },
  "session_id": "<uuid>"
}
```

**툴 호출 완료:**

```json  theme={null}
{
  "type": "tool_call",
  "subtype": "completed",
  "call_id": "<string id>",
  "tool_call": {
    "readToolCall": {
      "args": { "path": "file.txt" },
      "result": {
        "success": {
          "content": "파일 내용...",
          "isEmpty": false,
          "exceededLimit": false,
          "totalLines": 54,
          "totalChars": 1254
        }
      }
    }
  },
  "session_id": "<uuid>"
}
```

<div id="tool-call-types">
  #### 도구 호출 유형
</div>

**파일 읽기 도구:**

* **시작됨**: `tool_call.readToolCall.args`에 `{ "path": "file.txt" }` 포함
* **완료됨**: `tool_call.readToolCall.result.success`에 파일 메타데이터와 내용 포함

**파일 쓰기 도구:**

* **시작됨**: `tool_call.writeToolCall.args`에 `{ "path": "file.txt", "fileText": "content...", "toolCallId": "id" }` 포함
* **완료됨**: `tool_call.writeToolCall.result.success`에 `{ "path": "/absolute/path", "linesCreated": 19, "fileSize": 942 }` 포함

**기타 도구:**

* `{ "name": "tool_name", "arguments": "..." }`와 함께 `tool_call.function` 구조를 사용할 수 있음

<div id="terminal-result">
  #### 터미널 결과
</div>

성공적으로 완료될 때 내보내지는 최종 이벤트:

```json  theme={null}
{
  "type": "result",
  "subtype": "성공",
  "duration_ms": 1234,
  "duration_api_ms": 1234,
  "is_error": false,
  "result": "<전체 어시스턴트 텍스트>",
  "session_id": "<uuid>",
  "request_id": "<선택적 요청 ID>"
}
```

<div id="example-sequence">
  ### 예시 시퀀스
</div>

다음은 일반적인 이벤트 흐름을 보여주는 대표적인 NDJSON 시퀀스야:

```json  theme={null}
{"type":"system","subtype":"init","apiKeySource":"login","cwd":"/Users/user/project","session_id":"c6b62c6f-7ead-4fd6-9922-e952131177ff","model":"Claude 4 Sonnet","permissionMode":"default"}
{"type":"user","message":{"role":"user","content":[{"type":"text","text":"README.md를 읽고 요약해줘"}]},"session_id":"c6b62c6f-7ead-4fd6-9922-e952131177ff"}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"내가 "}]},"session_id":"c6b62c6f-7ead-4fd6-9922-e952131177ff"}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"README.md 파일을 읽을게"}]},"session_id":"c6b62c6f-7ead-4fd6-9922-e952131177ff"}
{"type":"tool_call","subtype":"started","call_id":"toolu_vrtx_01NnjaR886UcE8whekg2MGJd","tool_call":{"readToolCall":{"args":{"path":"README.md"}}},"session_id":"c6b62c6f-7ead-4fd6-9922-e952131177ff"}
{"type":"tool_call","subtype":"completed","call_id":"toolu_vrtx_01NnjaR886UcE8whekg2MGJd","tool_call":{"readToolCall":{"args":{"path":"README.md"},"result":{"success":{"content":"# 프로젝트\n\n샘플 프로젝트입니다...","isEmpty":false,"exceededLimit":false,"totalLines":54,"totalChars":1254}}}},"session_id":"c6b62c6f-7ead-4fd6-9922-e952131177ff"}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":" 그리고 요약할게"}]},"session_id":"c6b62c6f-7ead-4fd6-9922-e952131177ff"}
{"type":"tool_call","subtype":"started","call_id":"toolu_vrtx_01Q3VHVnWFSKygaRPT7WDxrv","tool_call":{"writeToolCall":{"args":{"path":"summary.txt","fileText":"# README 요약\n\n이 프로젝트는...","toolCallId":"toolu_vrtx_01Q3VHVnWFSKygaRPT7WDxrv"}}},"session_id":"c6b62c6f-7ead-4fd6-9922-e952131177ff"}
{"type":"tool_call","subtype":"completed","call_id":"toolu_vrtx_01Q3VHVnWFSKygaRPT7WDxrv","tool_call":{"writeToolCall":{"args":{"path":"summary.txt","fileText":"# README 요약\n\n이 프로젝트는...","toolCallId":"toolu_vrtx_01Q3VHVnWFSKygaRPT7WDxrv"},"result":{"success":{"path":"/Users/user/project/summary.txt","linesCreated":19,"fileSize":942}}}},"session_id":"c6b62c6f-7ead-4fd6-9922-e952131177ff"}
{"type":"result","subtype":"success","duration_ms":5234,"duration_api_ms":5234,"is_error":false,"result":"내가 README.md 파일을 읽고 요약할게","session_id":"c6b62c6f-7ead-4fd6-9922-e952131177ff","request_id":"10e11780-df2f-45dc-a1ff-4540af32e9c0"}
```

<div id="text-format">
  ## 텍스트 형식
</div>

`text` 출력 형식은 간결하고 사람이 읽기 쉬운 에이전트 동작 스트림을 제공해. 상세한 JSON 이벤트 대신, 에이전트가 실시간으로 무엇을 하는지에 대한 짧은 텍스트 설명을 출력해.

이 형식은 구조화된 데이터를 파싱하는 오버헤드 없이 에이전트 진행 상황을 모니터링하기에 유용해서, 로깅, 디버깅, 또는 간단한 진행 상황 추적에 이상적이야.

<div id="example-output">
  ### 출력 예시
</div>

```
파일 읽기
파일 편집
터미널 명령 실행
새 파일 생성
```

에이전트가 작업을 수행할 때마다 각 동작이 새 줄에 나타나서, 작업 진행 상황에 대한 즉각적인 피드백을 제공해.

<div id="implementation-notes">
  ## 구현 노트
</div>

* 각 이벤트는 `\n`으로 끝나는 한 줄로 출력됨
* `thinking` 이벤트는 print 모드에서 숨겨지며 어떤 출력 형식에도 나타나지 않음
* 필드는 시간이 지나며 역호환 방식으로 추가될 수 있음(클라이언트는 알 수 없는 필드를 무시해야 함)
* 스트림 형식은 실시간 업데이트를 제공하고, JSON 형식은 완료될 때까지 기다렸다가 결과를 출력함
* 전체 응답을 재구성하려면 모든 `assistant` 메시지 델타를 이어 붙이면 됨
* 툴 호출 ID로 시작/완료 이벤트를 매칭할 수 있음
* 세션 ID는 단일 에이전트 실행 내내 동일하게 유지됨



# 매개변수
Source: https://docs.cursor.com/ko/cli/reference/parameters

Cursor Agent CLI 전체 명령어 레퍼런스

<div id="global-options">
  ## 전역 옵션
</div>

전역 옵션은 어떤 명령이든 함께 쓸 수 있어:

<div class="full-width-table">
  | 옵션                         | 설명                                                                        |
  | -------------------------- | ------------------------------------------------------------------------- |
  | `-v, --version`            | 버전 번호 출력                                                                  |
  | `-a, --api-key <key>`      | 인증용 API 키 (`CURSOR_API_KEY` 환경 변수도 사용 가능)                                 |
  | `-p, --print`              | 콘솔에 응답 출력(스크립트나 비대화형 사용용). write랑 bash를 포함한 모든 도구에 접근 가능                  |
  | `--output-format <format>` | 출력 형식(`--print`에서만 동작): `text`, `json`, `stream-json` (기본: `stream-json`) |
  | `-b, --background`         | 백그라운드 모드로 시작(실행 시 컴포저 피커 열기)                                              |
  | `--fullscreen`             | 전체 화면 모드 켜기                                                               |
  | `--resume [chatId]`        | 채팅 세션 이어서 진행                                                              |
  | `-m, --model <model>`      | 사용할 모델                                                                    |
  | `-f, --force`              | 명시적으로 거부되지 않은 한 명령 강제 허용                                                  |
  | `-h, --help`               | 명령 도움말 표시                                                                 |
</div>

<div id="commands">
  ## Commands
</div>

<div class="full-width-table">
  | Command           | Description                | Usage                                           |
  | ----------------- | -------------------------- | ----------------------------------------------- |
  | `login`           | Cursor에 로그인                | `cursor-agent login`                            |
  | `logout`          | 로그아웃하고 저장된 인증 정보 삭제        | `cursor-agent logout`                           |
  | `status`          | 인증 상태 확인                   | `cursor-agent status`                           |
  | `mcp`             | MCP 서버 관리                  | `cursor-agent mcp`                              |
  | `update\|upgrade` | Cursor Agent를 최신 버전으로 업데이트 | `cursor-agent update` 또는 `cursor-agent upgrade` |
  | `ls`              | 채팅 세션 목록 보기                | `cursor-agent ls`                               |
  | `resume`          | 최신 채팅 세션 이어서 진행            | `cursor-agent resume`                           |
  | `help [command]`  | 명령어 도움말 표시                 | `cursor-agent help [command]`                   |
</div>

<Note>
  명령어를 지정하지 않으면 기본적으로 Cursor Agent가 대화형 채팅 모드로 시작해.
</Note>

<div id="mcp">
  ## MCP
</div>

Cursor Agent에 설정된 MCP 서버를 관리해.

<div class="full-width-table">
  | Subcommand                | Description                         | Usage                                      |
  | ------------------------- | ----------------------------------- | ------------------------------------------ |
  | `login <identifier>`      | `.cursor/mcp.json`에 설정된 MCP 서버에 인증해 | `cursor-agent mcp login <identifier>`      |
  | `list`                    | 설정된 MCP 서버와 상태를 목록으로 보여줘            | `cursor-agent mcp list`                    |
  | `list-tools <identifier>` | 특정 MCP에서 사용 가능한 도구와 해당 인자 이름을 보여줘   | `cursor-agent mcp list-tools <identifier>` |
</div>

모든 MCP 명령은 명령별 도움말을 위한 `-h, --help`를 지원해.

<div id="arguments">
  ## Arguments
</div>

채팅 모드로 시작할 때(기본 동작), 초기 프롬프트를 제공할 수 있어:

**Arguments:**

* `prompt` — 에이전트의 초기 프롬프트

<div id="getting-help">
  ## 도움말
</div>

모든 명령에는 명령별 도움말을 보여주는 전역 `-h, --help` 옵션이 있어.



# 권한
Source: https://docs.cursor.com/ko/cli/reference/permissions

파일과 명령에 대한 에이전트 액세스를 제어하는 권한 유형

CLI 설정에서 permission 토큰을 사용해 에이전트가 할 수 있는 작업을 설정해. 권한은 `~/.cursor/cli-config.json`(전역) 또는 `<project>/.cursor/cli.json`(프로젝트별)에 설정돼.

<div id="permission-types">
  ## 권한 유형
</div>

<div id="shell-commands">
  ### Shell 명령
</div>

**형식:** `Shell(commandBase)`

Shell 명령 접근을 제어해. `commandBase`는 커맨드 라인의 첫 번째 토큰이야.

<div class="full-width-table">
  | Example      | Description                  |
  | ------------ | ---------------------------- |
  | `Shell(ls)`  | `ls` 명령 실행 허용                |
  | `Shell(git)` | 모든 `git` 하위 명령 허용            |
  | `Shell(npm)` | npm 패키지 관리자 명령 허용            |
  | `Shell(rm)`  | 파괴적인 파일 삭제 거부(보통 `deny`에 설정) |
</div>

<div id="file-reads">
  ### 파일 읽기
</div>

**형식:** `Read(pathOrGlob)`

파일과 디렉터리 읽기 접근을 제어해. glob 패턴을 지원해.

<div class="full-width-table">
  | Example             | Description                |
  | ------------------- | -------------------------- |
  | `Read(src/**/*.ts)` | `src`의 TypeScript 파일 읽기 허용 |
  | `Read(**/*.md)`     | 어디서나 Markdown 파일 읽기 허용     |
  | `Read(.env*)`       | 환경 파일 읽기 거부                |
  | `Read(/etc/passwd)` | 시스템 파일 읽기 거부               |
</div>

<div id="file-writes">
  ### 파일 쓰기
</div>

**형식:** `Write(pathOrGlob)`

파일과 디렉터리 쓰기 접근을 제어해. glob 패턴을 지원해. print 모드에서 쓸 때는 파일을 작성하려면 `--force`가 필요해.

<div class="full-width-table">
  | Example               | Description          |
  | --------------------- | -------------------- |
  | `Write(src/**)`       | `src` 아래 모든 파일 쓰기 허용 |
  | `Write(package.json)` | package.json 수정 허용   |
  | `Write(**/*.key)`     | 개인 키 파일 쓰기 거부        |
  | `Write(**/.env*)`     | 환경 파일 쓰기 거부          |
</div>

<div id="configuration">
  ## 구성
</div>

CLI 구성 파일의 `permissions` 객체에 권한을 추가해:

```json  theme={null}
{
  "permissions": {
    "allow": [
      "Shell(ls)",
      "Shell(git)", 
      "Read(src/**/*.ts)",
      "Write(package.json)"
    ],
    "deny": [
      "Shell(rm)",
      "Read(.env*)",
      "Write(**/*.key)"
    ]
  }
}
```

<div id="pattern-matching">
  ## 패턴 매칭
</div>

* 글롭 패턴은 `**`, `*`, `?` 와일드카드를 사용해
* 상대 경로는 현재 워크스페이스 기준으로 범위가 정해져
* 절대 경로는 프로젝트 밖의 파일도 지정할 수 있어
* 거부 규칙이 허용 규칙보다 우선이야



# Slash commands
Source: https://docs.cursor.com/ko/cli/reference/slash-commands

Cursor CLI 세션에서 사용할 수 있는 빠른 액션

<div class="full-width-table">
  | Command               | Description                           |
  | --------------------- | ------------------------------------- |
  | `/model <model>`      | 모델 설정 또는 목록 보기                        |
  | `/auto-run [state]`   | 자동 실행 전환(기본) 또는 \[on\|off\|status] 설정 |
  | `/new-chat`           | 새 채팅 세션 시작                            |
  | `/vim`                | Vim 키 전환                              |
  | `/help [command]`     | 도움말 표시 (/help \[cmd])                 |
  | `/feedback <message>` | 팀에 피드백 보내기                            |
  | `/resume <chat>`      | 폴더 이름으로 이전 채팅 이어가기                    |
  | `/copy-req-id`        | 마지막 요청 ID 복사                          |
  | `/logout`             | Cursor에서 로그아웃                         |
  | `/quit`               | 종료                                    |
</div>




---

**Navigation:** [← Previous](./22-tab.md) | [Index](./index.md) | [Next →](./24-shell-모드.md)