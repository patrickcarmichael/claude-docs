---
title: "Cohere Documentation"
description: "Formatted documentation for Cohere"
source: "llms-full.txt"
last_updated: "2025-11-08"
---

## Example response

{
  "title": "The Great Gatsby",
  "author": "F. Scott Fitzgerald",
  "publication_year": 1925
}
```

### Nested Array Schema Json Example

Here's an example of a nested array. Note that the top level json structure must always be a json object.

<CodeBlocks>
```python PYTHON
  cohere_api_key = os.getenv("cohere_api_key")
  co = cohere.ClientV2(cohere_api_key)
  response = co.chat(
      response_format={
          "type": "json_object",
          "schema": {
              "type": "object",
              "properties": {
                  "actions": {
                      "type": "array",
                      "items": {
                          "type": "object",
                          "properties": {
                              "japanese": {"type": "string"},
                              "romaji": {"type": "string"},
                              "english": {"type": "string"},
                          },
                          "required": ["japanese", "romaji", "english"],
                      },
                  }
              },
              "required": ["actions"],
          },
      },
      model="command-a-03-2025",
      messages=[
          {
              "role": "user",
              "content": "Generate a JSON array of objects with the following fields: japanese, romaji, english. These actions should be japanese verbs provided in the dictionary form.",
          },
      ],
  )
  return json.loads(response.message.content[0].text)
```
```bash cURL
  curl --request POST \
    --url https://api.cohere.ai/v2/chat \
    --header 'accept: application/json' \
    --header 'content-type: application/json' \
    --header "Authorization: bearer $CO_API_KEY" \
    --data '{
      "model": "command-a-03-2025",
      "messages": [
        {
          "role": "user",
          "content": "Generate a JSON array of objects with the following fields: japanese, romaji, english. These actions should be japanese verbs provided in the dictionary form."
        }
      ],
      "response_format": {
        "type": "json_object",
        "schema": {
          "type": "object",
          "properties": {
            "actions": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "japanese": {"type": "string"},
                  "romaji": {"type": "string"},
                  "english": {"type": "string"}
                },
                "required": ["japanese", "romaji", "english"]
              }
            }
          },
          "required": ["actions"]
        }
      }
    }'
```
</CodeBlocks>

The output for this example would be:
```json
{
    "actions": [
        {"japanese": "„ÅÑ„Åì„ÅÜ", "romaji": "ikou", "english": "onward"},
        {"japanese": "Êé¢„Åô", "romaji": "sagasu", "english": "search"},
        {"japanese": "Ë©±„Åô", "romaji": "hanasu", "english": "talk"}
    ]
}
```
<Info title="Important">
  Note: Each schema provided (in both JSON and Tools modes) will incur a latency overhead required for processing the schema. This is only applicable for the first few requests.
</Info>

### Structured Outputs (Tools)

When you use the Chat API with `tools` (see [tool use](https://docs.cohere.com/docs/tool-use) and [agents](https://docs.cohere.com/docs/multi-step-tool-use)), setting the `strict_tools` parameter to `True`  will enforce that the tool calls generated by the mode strictly adhere to the tool descriptions you provided.

Concretely, this means:

* No hallucinated tool names
* No hallucinated tool parameters
* Every `required` parameter is included in the tool call
* All parameters produce the requested data types

With `strict_tools` enabled, the API will ensure that the tool names and tool parameters are generated according to the tool definitions. This eliminates tool name and parameter hallucinations, ensures that each parameter matches the specified data type, and that all required parameters are included in the model response.

Additionally, this results in faster development. You don‚Äôt need to spend a lot of time prompt engineering the model to avoid hallucinations.

In the example below, we create a tool that can retrieve weather data for a given location. The tool is called `get_weather` which contains a parameter called `location`. We then invoke the Chat API with `strict_tools` set to `True` to ensure that the generated tool calls always include the correct function and parameter names.

When the `strict_tools` parameter is set to `True`, you can define a maximum of 200 fields across all tools being passed to an API call.

<CodeBlocks>
```python PYTHON {24}
  tools = [
      {
          "type": "function",
          "function": {
              "name": "get_weather",
              "description" : "Gets the weather of a given location",
              "parameters": {
                  "type": "object",
                  "properties": {
                      "location": {
                          "type" : "string",
                          "description": "The location to get weather."
                      }
                  },
                  "required": ["location"]
              }
          }
      },
  ]

  response = co.chat(model="command-r7b-12-2024",
                     messages=[{"role": "user", "content": "What's the weather in Toronto?"}],
                     tools=tools,
                     strict_tools=True)

  print(response.message.tool_calls)
```
```bash cURL
  curl --request POST \
    --url https://api.cohere.ai/v2/chat \
    --header 'accept: application/json' \
    --header 'content-type: application/json' \
    --header "Authorization: bearer $CO_API_KEY" \
    --data '{
      "model": "command-r7b-12-2024",
      "messages": [
        {
          "role": "user",
          "content": "What'\''s the weather in Toronto?"
        }
      ],
      "tools": [
        {
          "type": "function",
          "function": {
            "name": "get_weather",
            "description": "Gets the weather of a given location",
            "parameters": {
              "type": "object",
              "properties": {
                "location": {
                  "type": "string",
                  "description": "The location to get weather."
                }
              },
              "required": ["location"]
            }
          }
        }
      ],
      "strict_tools": true
    }'
```python
</CodeBlocks>

#### Important notes on using `strict_tools`

* This parameter is only supported in Chat API V2 via the strict\_tools parameter (not API V1).
* You must specify at least one `required` parameter. Tools with only optional parameters are not supported in this mode.
* You can define a maximum of 200 fields across all tools in a single Chat API call.

<Note title="Experimental">
  `strict_tools` is currently an experimental parameter. We‚Äôll be iterating on this feature and are looking for feedback. Share your experience with us in the `#api-discussions` channel on [discord](https://discord.gg/co-mmunity) or via [email](mailto:tools_feedback@cohere.com).
</Note>

### When to Use Structured Outputs (JSON) vs. Structured Outputs (Tools)

Structured Outputs (JSON) are ideal for text generation use cases where you want to format the model's responses to users in a specific way.

For example, when building a travel planner application, you might want the LLM to generate itineraries in a specific JSON format, allowing the application to use the output in the other parts of the application.

Structured Outputs (Tools) are ideal for [tool use (or function calling)](https://docs.cohere.com/docs/tool-use) and [agents](https://docs.cohere.com/docs/multi-step-tool-use) use cases where you need the model to interact with external data or services. For instance, you can grant the model access to functions that interact with databases or other APIs.

In summary, opt for:

* Structured Outputs (JSON) when you need the model's response to follow a specific structure.
* Structured Outputs (Tools) when you need the model to interact with external data or services.

---

**üìö [Back to Index](./index.md)** | **üìÑ [Full Version](./documentation.md)** | **üîó [Original](../llms-full.txt)**
